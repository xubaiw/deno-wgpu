/**
 * @file This file is generated by "../tool/gen.ts#writeTier2" and should not be modified manually.
 */
import * as U from "./util.ts";
import lib from "./tier1.ts";

export enum AdapterType {
  DiscreteGPU = 0,
  IntegratedGPU = 1,
  CPU = 2,
  Unknown = 3,
}
export enum AddressMode {
  Repeat = 0,
  MirrorRepeat = 1,
  ClampToEdge = 2,
}
export enum BackendType {
  Undefined = 0,
  Null = 1,
  WebGPU = 2,
  D3D11 = 3,
  D3D12 = 4,
  Metal = 5,
  Vulkan = 6,
  OpenGL = 7,
  OpenGLES = 8,
}
export enum BlendFactor {
  Zero = 0,
  One = 1,
  Src = 2,
  OneMinusSrc = 3,
  SrcAlpha = 4,
  OneMinusSrcAlpha = 5,
  Dst = 6,
  OneMinusDst = 7,
  DstAlpha = 8,
  OneMinusDstAlpha = 9,
  SrcAlphaSaturated = 10,
  Constant = 11,
  OneMinusConstant = 12,
}
export enum BlendOperation {
  Add = 0,
  Subtract = 1,
  ReverseSubtract = 2,
  Min = 3,
  Max = 4,
}
export enum BufferBindingType {
  Undefined = 0,
  Uniform = 1,
  Storage = 2,
  ReadOnlyStorage = 3,
}
export enum BufferMapAsyncStatus {
  Success = 0,
  ValidationError = 1,
  Unknown = 2,
  DeviceLost = 3,
  DestroyedBeforeCallback = 4,
  UnmappedBeforeCallback = 5,
  MappingAlreadyPending = 6,
  OffsetOutOfRange = 7,
  SizeOutOfRange = 8,
}
export enum BufferMapState {
  Unmapped = 0,
  Pending = 1,
  Mapped = 2,
}
export enum CompareFunction {
  Undefined = 0,
  Never = 1,
  Less = 2,
  LessEqual = 3,
  Greater = 4,
  GreaterEqual = 5,
  Equal = 6,
  NotEqual = 7,
  Always = 8,
}
export enum CompilationInfoRequestStatus {
  Success = 0,
  Error = 1,
  DeviceLost = 2,
  Unknown = 3,
}
export enum CompilationMessageType {
  Error = 0,
  Warning = 1,
  Info = 2,
}
export enum ComputePassTimestampLocation {
  Beginning = 0,
  End = 1,
}
export enum CreatePipelineAsyncStatus {
  Success = 0,
  ValidationError = 1,
  InternalError = 2,
  DeviceLost = 3,
  DeviceDestroyed = 4,
  Unknown = 5,
}
export enum CullMode {
  None = 0,
  Front = 1,
  Back = 2,
}
export enum DeviceLostReason {
  Undefined = 0,
  Destroyed = 1,
}
export enum ErrorFilter {
  Validation = 0,
  OutOfMemory = 1,
  Internal = 2,
}
export enum ErrorType {
  NoError = 0,
  Validation = 1,
  OutOfMemory = 2,
  Internal = 3,
  Unknown = 4,
  DeviceLost = 5,
}
export enum FeatureName {
  Undefined = 0,
  DepthClipControl = 1,
  Depth32FloatStencil8 = 2,
  TimestampQuery = 3,
  PipelineStatisticsQuery = 4,
  TextureCompressionBC = 5,
  TextureCompressionETC2 = 6,
  TextureCompressionASTC = 7,
  IndirectFirstInstance = 8,
  ShaderF16 = 9,
  RG11B10UfloatRenderable = 10,
  BGRA8UnormStorage = 11,
  Float32Filterable = 12,
  PushConstants = 1610612737,
  TextureAdapterSpecificFormatFeatures = 1610612738,
  MultiDrawIndirect = 1610612739,
  MultiDrawIndirectCount = 1610612740,
  VertexWritableStorage = 1610612741,
}
export enum FilterMode {
  Nearest = 0,
  Linear = 1,
}
export enum FrontFace {
  CCW = 0,
  CW = 1,
}
export enum IndexFormat {
  Undefined = 0,
  Uint16 = 1,
  Uint32 = 2,
}
export enum LoadOp {
  Undefined = 0,
  Clear = 1,
  Load = 2,
}
export enum MipmapFilterMode {
  Nearest = 0,
  Linear = 1,
}
export enum PipelineStatisticName {
  VertexShaderInvocations = 0,
  ClipperInvocations = 1,
  ClipperPrimitivesOut = 2,
  FragmentShaderInvocations = 3,
  ComputeShaderInvocations = 4,
}
export enum PowerPreference {
  Undefined = 0,
  LowPower = 1,
  HighPerformance = 2,
}
export enum PresentMode {
  Immediate = 0,
  Mailbox = 1,
  Fifo = 2,
}
export enum PrimitiveTopology {
  PointList = 0,
  LineList = 1,
  LineStrip = 2,
  TriangleList = 3,
  TriangleStrip = 4,
}
export enum QueryType {
  Occlusion = 0,
  PipelineStatistics = 1,
  Timestamp = 2,
}
export enum QueueWorkDoneStatus {
  Success = 0,
  Error = 1,
  Unknown = 2,
  DeviceLost = 3,
}
export enum RenderPassTimestampLocation {
  Beginning = 0,
  End = 1,
}
export enum RequestAdapterStatus {
  Success = 0,
  Unavailable = 1,
  Error = 2,
  Unknown = 3,
}
export enum RequestDeviceStatus {
  Success = 0,
  Error = 1,
  Unknown = 2,
}
export enum SType {
  Invalid = 0,
  SurfaceDescriptorFromMetalLayer = 1,
  SurfaceDescriptorFromWindowsHWND = 2,
  SurfaceDescriptorFromXlibWindow = 3,
  SurfaceDescriptorFromCanvasHTMLSelector = 4,
  ShaderModuleSPIRVDescriptor = 5,
  ShaderModuleWGSLDescriptor = 6,
  PrimitiveDepthClipControl = 7,
  SurfaceDescriptorFromWaylandSurface = 8,
  SurfaceDescriptorFromAndroidNativeWindow = 9,
  SurfaceDescriptorFromXcbWindow = 10,
  RenderPassDescriptorMaxDrawCount = 15,
  DeviceExtras = 1610612737,
  AdapterExtras = 1610612738,
  RequiredLimitsExtras = 1610612739,
  PipelineLayoutExtras = 1610612740,
  ShaderModuleGLSLDescriptor = 1610612741,
  SupportedLimitsExtras = 1610612739,
  InstanceExtras = 1610612742,
  SwapChainDescriptorExtras = 1610612743,
}
export enum SamplerBindingType {
  Undefined = 0,
  Filtering = 1,
  NonFiltering = 2,
  Comparison = 3,
}
export enum StencilOperation {
  Keep = 0,
  Zero = 1,
  Replace = 2,
  Invert = 3,
  IncrementClamp = 4,
  DecrementClamp = 5,
  IncrementWrap = 6,
  DecrementWrap = 7,
}
export enum StorageTextureAccess {
  Undefined = 0,
  WriteOnly = 1,
}
export enum StoreOp {
  Undefined = 0,
  Store = 1,
  Discard = 2,
}
export enum TextureAspect {
  All = 0,
  StencilOnly = 1,
  DepthOnly = 2,
}
export enum TextureDimension {
  _1D = 0,
  _2D = 1,
  _3D = 2,
}
export enum TextureFormat {
  Undefined = 0,
  R8Unorm = 1,
  R8Snorm = 2,
  R8Uint = 3,
  R8Sint = 4,
  R16Uint = 5,
  R16Sint = 6,
  R16Float = 7,
  RG8Unorm = 8,
  RG8Snorm = 9,
  RG8Uint = 10,
  RG8Sint = 11,
  R32Float = 12,
  R32Uint = 13,
  R32Sint = 14,
  RG16Uint = 15,
  RG16Sint = 16,
  RG16Float = 17,
  RGBA8Unorm = 18,
  RGBA8UnormSrgb = 19,
  RGBA8Snorm = 20,
  RGBA8Uint = 21,
  RGBA8Sint = 22,
  BGRA8Unorm = 23,
  BGRA8UnormSrgb = 24,
  RGB10A2Unorm = 25,
  RG11B10Ufloat = 26,
  RGB9E5Ufloat = 27,
  RG32Float = 28,
  RG32Uint = 29,
  RG32Sint = 30,
  RGBA16Uint = 31,
  RGBA16Sint = 32,
  RGBA16Float = 33,
  RGBA32Float = 34,
  RGBA32Uint = 35,
  RGBA32Sint = 36,
  Stencil8 = 37,
  Depth16Unorm = 38,
  Depth24Plus = 39,
  Depth24PlusStencil8 = 40,
  Depth32Float = 41,
  Depth32FloatStencil8 = 42,
  BC1RGBAUnorm = 43,
  BC1RGBAUnormSrgb = 44,
  BC2RGBAUnorm = 45,
  BC2RGBAUnormSrgb = 46,
  BC3RGBAUnorm = 47,
  BC3RGBAUnormSrgb = 48,
  BC4RUnorm = 49,
  BC4RSnorm = 50,
  BC5RGUnorm = 51,
  BC5RGSnorm = 52,
  BC6HRGBUfloat = 53,
  BC6HRGBFloat = 54,
  BC7RGBAUnorm = 55,
  BC7RGBAUnormSrgb = 56,
  ETC2RGB8Unorm = 57,
  ETC2RGB8UnormSrgb = 58,
  ETC2RGB8A1Unorm = 59,
  ETC2RGB8A1UnormSrgb = 60,
  ETC2RGBA8Unorm = 61,
  ETC2RGBA8UnormSrgb = 62,
  EACR11Unorm = 63,
  EACR11Snorm = 64,
  EACRG11Unorm = 65,
  EACRG11Snorm = 66,
  ASTC4x4Unorm = 67,
  ASTC4x4UnormSrgb = 68,
  ASTC5x4Unorm = 69,
  ASTC5x4UnormSrgb = 70,
  ASTC5x5Unorm = 71,
  ASTC5x5UnormSrgb = 72,
  ASTC6x5Unorm = 73,
  ASTC6x5UnormSrgb = 74,
  ASTC6x6Unorm = 75,
  ASTC6x6UnormSrgb = 76,
  ASTC8x5Unorm = 77,
  ASTC8x5UnormSrgb = 78,
  ASTC8x6Unorm = 79,
  ASTC8x6UnormSrgb = 80,
  ASTC8x8Unorm = 81,
  ASTC8x8UnormSrgb = 82,
  ASTC10x5Unorm = 83,
  ASTC10x5UnormSrgb = 84,
  ASTC10x6Unorm = 85,
  ASTC10x6UnormSrgb = 86,
  ASTC10x8Unorm = 87,
  ASTC10x8UnormSrgb = 88,
  ASTC10x10Unorm = 89,
  ASTC10x10UnormSrgb = 90,
  ASTC12x10Unorm = 91,
  ASTC12x10UnormSrgb = 92,
  ASTC12x12Unorm = 93,
  ASTC12x12UnormSrgb = 94,
}
export enum TextureSampleType {
  Undefined = 0,
  Float = 1,
  UnfilterableFloat = 2,
  Depth = 3,
  Sint = 4,
  Uint = 5,
}
export enum TextureViewDimension {
  Undefined = 0,
  _1D = 1,
  _2D = 2,
  _2DArray = 3,
  Cube = 4,
  CubeArray = 5,
  _3D = 6,
}
export enum VertexFormat {
  Undefined = 0,
  Uint8x2 = 1,
  Uint8x4 = 2,
  Sint8x2 = 3,
  Sint8x4 = 4,
  Unorm8x2 = 5,
  Unorm8x4 = 6,
  Snorm8x2 = 7,
  Snorm8x4 = 8,
  Uint16x2 = 9,
  Uint16x4 = 10,
  Sint16x2 = 11,
  Sint16x4 = 12,
  Unorm16x2 = 13,
  Unorm16x4 = 14,
  Snorm16x2 = 15,
  Snorm16x4 = 16,
  Float16x2 = 17,
  Float16x4 = 18,
  Float32 = 19,
  Float32x2 = 20,
  Float32x3 = 21,
  Float32x4 = 22,
  Uint32 = 23,
  Uint32x2 = 24,
  Uint32x3 = 25,
  Uint32x4 = 26,
  Sint32 = 27,
  Sint32x2 = 28,
  Sint32x3 = 29,
  Sint32x4 = 30,
}
export enum VertexStepMode {
  Vertex = 0,
  Instance = 1,
  VertexBufferNotUsed = 2,
}
export enum BufferUsage {
  None = 0,
  MapRead = 1,
  MapWrite = 2,
  CopySrc = 4,
  CopyDst = 8,
  Index = 16,
  Vertex = 32,
  Uniform = 64,
  Storage = 128,
  Indirect = 256,
  QueryResolve = 512,
}
export enum ColorWriteMask {
  None = 0,
  Red = 1,
  Green = 2,
  Blue = 4,
  Alpha = 8,
  All = 15,
}
export enum MapMode {
  None = 0,
  Read = 1,
  Write = 2,
}
export enum ShaderStage {
  None = 0,
  Vertex = 1,
  Fragment = 2,
  Compute = 4,
}
export enum TextureUsage {
  None = 0,
  CopySrc = 1,
  CopyDst = 2,
  TextureBinding = 4,
  StorageBinding = 8,
  RenderAttachment = 16,
}
export enum LogLevel {
  Off = 0,
  Error = 1,
  Warn = 2,
  Info = 3,
  Debug = 4,
  Trace = 5,
}
export enum InstanceBackend {
  Vulkan = 2,
  GL = 32,
  Metal = 4,
  DX12 = 8,
  DX11 = 16,
  BrowserWebGPU = 64,
  Primary = 78,
  Secondary = 48,
  None = 0,
}
export enum Dx12Compiler {
  Undefined = 0,
  Fxc = 1,
  Dxc = 2,
}
export enum CompositeAlphaMode {
  Auto = 0,
  Opaque = 1,
  PreMultiplied = 2,
  PostMultiplied = 3,
  Inherit = 4,
}

export type ToAdapterProperties = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStructOut | ToChainedStructOut;
    [key: string]: any;
  };
  vendorID?: number;
  vendorName?: Deno.PointerValue;
  architecture?: Deno.PointerValue;
  deviceID?: number;
  name?: Deno.PointerValue;
  driverDescription?: Deno.PointerValue;
  adapterType?: AdapterType;
  backendType?: BackendType;
};

export class AdapterProperties extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(64));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(64),
        );
      }
    }
  }

  get nextInChain(): ChainedStructOut | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStructOut(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStructOut | ToChainedStructOut;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get vendorID(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set vendorID(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get vendorName(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set vendorName(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get architecture(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set architecture(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get deviceID(): number {
    return this.dataview.getUint32(32, U.LE);
  }

  set deviceID(value: number) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get name(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(40, U.LE));
    return ptr;
  }

  set name(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      40,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get driverDescription(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(48, U.LE));
    return ptr;
  }

  set driverDescription(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      48,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get adapterType(): AdapterType {
    return this.dataview.getUint32(56, U.LE) as AdapterType;
  }

  set adapterType(value: AdapterType) {
    this.dataview.setUint32(56, value, U.LE);
  }

  get backendType(): BackendType {
    return this.dataview.getUint32(60, U.LE) as BackendType;
  }

  set backendType(value: BackendType) {
    this.dataview.setUint32(60, value, U.LE);
  }

  static from(plain: ToAdapterProperties) {
    const struct = new AdapterProperties();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.vendorID !== undefined) struct.vendorID = plain.vendorID;
    if (plain.vendorName !== undefined) struct.vendorName = plain.vendorName;
    if (plain.architecture !== undefined) {
      struct.architecture = plain.architecture;
    }
    if (plain.deviceID !== undefined) struct.deviceID = plain.deviceID;
    if (plain.name !== undefined) struct.name = plain.name;
    if (plain.driverDescription !== undefined) {
      struct.driverDescription = plain.driverDescription;
    }
    if (plain.adapterType !== undefined) struct.adapterType = plain.adapterType;
    if (plain.backendType !== undefined) struct.backendType = plain.backendType;
    return struct;
  }
  set(plain: ToAdapterProperties) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.vendorID !== undefined) this.vendorID = plain.vendorID;
    if (plain.vendorName !== undefined) this.vendorName = plain.vendorName;
    if (plain.architecture !== undefined) {
      this.architecture = plain.architecture;
    }
    if (plain.deviceID !== undefined) this.deviceID = plain.deviceID;
    if (plain.name !== undefined) this.name = plain.name;
    if (plain.driverDescription !== undefined) {
      this.driverDescription = plain.driverDescription;
    }
    if (plain.adapterType !== undefined) this.adapterType = plain.adapterType;
    if (plain.backendType !== undefined) this.backendType = plain.backendType;
  }
}

export type ToBindGroupEntry = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  binding?: number;
  buffer?: Deno.PointerValue | Buffer;
  offset?: bigint | number;
  size?: bigint | number;
  sampler?: Deno.PointerValue | Sampler;
  textureView?: Deno.PointerValue | TextureView;
};

export class BindGroupEntry extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(56));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(56),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get binding(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set binding(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get buffer(): Buffer {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return new Buffer(ptr);
  }

  set buffer(value: Deno.PointerValue | Buffer) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get offset(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set offset(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get size(): bigint {
    return this.dataview.getBigUint64(32, U.LE);
  }

  set size(value: bigint | number) {
    this.dataview.setBigUint64(32, BigInt(value), U.LE);
  }

  get sampler(): Sampler {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(40, U.LE));
    return new Sampler(ptr);
  }

  set sampler(value: Deno.PointerValue | Sampler) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      40,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get textureView(): TextureView {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(48, U.LE));
    return new TextureView(ptr);
  }

  set textureView(value: Deno.PointerValue | TextureView) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      48,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToBindGroupEntry) {
    const struct = new BindGroupEntry();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.binding !== undefined) struct.binding = plain.binding;
    if (plain.buffer !== undefined) struct.buffer = plain.buffer;
    if (plain.offset !== undefined) struct.offset = plain.offset;
    if (plain.size !== undefined) struct.size = plain.size;
    if (plain.sampler !== undefined) struct.sampler = plain.sampler;
    if (plain.textureView !== undefined) struct.textureView = plain.textureView;
    return struct;
  }
  set(plain: ToBindGroupEntry) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.binding !== undefined) this.binding = plain.binding;
    if (plain.buffer !== undefined) this.buffer = plain.buffer;
    if (plain.offset !== undefined) this.offset = plain.offset;
    if (plain.size !== undefined) this.size = plain.size;
    if (plain.sampler !== undefined) this.sampler = plain.sampler;
    if (plain.textureView !== undefined) this.textureView = plain.textureView;
  }
}

export type ToBlendComponent = undefined | {
  operation?: BlendOperation;
  srcFactor?: BlendFactor;
  dstFactor?: BlendFactor;
};

export class BlendComponent extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(12));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(12),
        );
      }
    }
  }

  get operation(): BlendOperation {
    return this.dataview.getUint32(0, U.LE) as BlendOperation;
  }

  set operation(value: BlendOperation) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get srcFactor(): BlendFactor {
    return this.dataview.getUint32(4, U.LE) as BlendFactor;
  }

  set srcFactor(value: BlendFactor) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get dstFactor(): BlendFactor {
    return this.dataview.getUint32(8, U.LE) as BlendFactor;
  }

  set dstFactor(value: BlendFactor) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToBlendComponent) {
    const struct = new BlendComponent();
    if (plain === undefined) return struct;
    if (plain.operation !== undefined) struct.operation = plain.operation;
    if (plain.srcFactor !== undefined) struct.srcFactor = plain.srcFactor;
    if (plain.dstFactor !== undefined) struct.dstFactor = plain.dstFactor;
    return struct;
  }
  set(plain: ToBlendComponent) {
    if (plain === undefined) return;
    if (plain.operation !== undefined) this.operation = plain.operation;
    if (plain.srcFactor !== undefined) this.srcFactor = plain.srcFactor;
    if (plain.dstFactor !== undefined) this.dstFactor = plain.dstFactor;
  }
}

export type ToBufferBindingLayout = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  type?: BufferBindingType;
  hasDynamicOffset?: boolean | number | bigint;
  minBindingSize?: bigint | number;
};

export class BufferBindingLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get type(): BufferBindingType {
    return this.dataview.getUint32(8, U.LE) as BufferBindingType;
  }

  set type(value: BufferBindingType) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get hasDynamicOffset(): boolean {
    return this.dataview.getUint8(12) == 1;
  }

  set hasDynamicOffset(value: boolean | number | bigint) {
    this.dataview.setUint8(12, value ? 1 : 0);
  }

  get minBindingSize(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set minBindingSize(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  static from(plain: ToBufferBindingLayout) {
    const struct = new BufferBindingLayout();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.type !== undefined) struct.type = plain.type;
    if (plain.hasDynamicOffset !== undefined) {
      struct.hasDynamicOffset = plain.hasDynamicOffset;
    }
    if (plain.minBindingSize !== undefined) {
      struct.minBindingSize = plain.minBindingSize;
    }
    return struct;
  }
  set(plain: ToBufferBindingLayout) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.type !== undefined) this.type = plain.type;
    if (plain.hasDynamicOffset !== undefined) {
      this.hasDynamicOffset = plain.hasDynamicOffset;
    }
    if (plain.minBindingSize !== undefined) {
      this.minBindingSize = plain.minBindingSize;
    }
  }
}

export type ToBufferDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  usage?: number;
  size?: bigint | number;
  mappedAtCreation?: boolean | number | bigint;
};

export class BufferDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get usage(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set usage(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get size(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set size(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get mappedAtCreation(): boolean {
    return this.dataview.getUint8(32) == 1;
  }

  set mappedAtCreation(value: boolean | number | bigint) {
    this.dataview.setUint8(32, value ? 1 : 0);
  }

  static from(plain: ToBufferDescriptor) {
    const struct = new BufferDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.usage !== undefined) struct.usage = plain.usage;
    if (plain.size !== undefined) struct.size = plain.size;
    if (plain.mappedAtCreation !== undefined) {
      struct.mappedAtCreation = plain.mappedAtCreation;
    }
    return struct;
  }
  set(plain: ToBufferDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.usage !== undefined) this.usage = plain.usage;
    if (plain.size !== undefined) this.size = plain.size;
    if (plain.mappedAtCreation !== undefined) {
      this.mappedAtCreation = plain.mappedAtCreation;
    }
  }
}

export type ToColor = undefined | {
  r?: number;
  g?: number;
  b?: number;
  a?: number;
};

export class Color extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get r(): number {
    return this.dataview.getFloat64(0, U.LE);
  }

  set r(value: number) {
    this.dataview.setFloat64(0, value, U.LE);
  }

  get g(): number {
    return this.dataview.getFloat64(8, U.LE);
  }

  set g(value: number) {
    this.dataview.setFloat64(8, value, U.LE);
  }

  get b(): number {
    return this.dataview.getFloat64(16, U.LE);
  }

  set b(value: number) {
    this.dataview.setFloat64(16, value, U.LE);
  }

  get a(): number {
    return this.dataview.getFloat64(24, U.LE);
  }

  set a(value: number) {
    this.dataview.setFloat64(24, value, U.LE);
  }

  static from(plain: ToColor) {
    const struct = new Color();
    if (plain === undefined) return struct;
    if (plain.r !== undefined) struct.r = plain.r;
    if (plain.g !== undefined) struct.g = plain.g;
    if (plain.b !== undefined) struct.b = plain.b;
    if (plain.a !== undefined) struct.a = plain.a;
    return struct;
  }
  set(plain: ToColor) {
    if (plain === undefined) return;
    if (plain.r !== undefined) this.r = plain.r;
    if (plain.g !== undefined) this.g = plain.g;
    if (plain.b !== undefined) this.b = plain.b;
    if (plain.a !== undefined) this.a = plain.a;
  }
}

export type ToCommandBufferDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
};

export class CommandBufferDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToCommandBufferDescriptor) {
    const struct = new CommandBufferDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    return struct;
  }
  set(plain: ToCommandBufferDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
  }
}

export type ToCommandEncoderDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
};

export class CommandEncoderDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToCommandEncoderDescriptor) {
    const struct = new CommandEncoderDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    return struct;
  }
  set(plain: ToCommandEncoderDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
  }
}

export type ToCompilationMessage = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  message?: Deno.PointerValue;
  type?: CompilationMessageType;
  lineNum?: bigint | number;
  linePos?: bigint | number;
  offset?: bigint | number;
  length?: bigint | number;
  utf16LinePos?: bigint | number;
  utf16Offset?: bigint | number;
  utf16Length?: bigint | number;
};

export class CompilationMessage extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(80));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(80),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get message(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set message(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get type(): CompilationMessageType {
    return this.dataview.getUint32(16, U.LE) as CompilationMessageType;
  }

  set type(value: CompilationMessageType) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get lineNum(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set lineNum(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get linePos(): bigint {
    return this.dataview.getBigUint64(32, U.LE);
  }

  set linePos(value: bigint | number) {
    this.dataview.setBigUint64(32, BigInt(value), U.LE);
  }

  get offset(): bigint {
    return this.dataview.getBigUint64(40, U.LE);
  }

  set offset(value: bigint | number) {
    this.dataview.setBigUint64(40, BigInt(value), U.LE);
  }

  get length(): bigint {
    return this.dataview.getBigUint64(48, U.LE);
  }

  set length(value: bigint | number) {
    this.dataview.setBigUint64(48, BigInt(value), U.LE);
  }

  get utf16LinePos(): bigint {
    return this.dataview.getBigUint64(56, U.LE);
  }

  set utf16LinePos(value: bigint | number) {
    this.dataview.setBigUint64(56, BigInt(value), U.LE);
  }

  get utf16Offset(): bigint {
    return this.dataview.getBigUint64(64, U.LE);
  }

  set utf16Offset(value: bigint | number) {
    this.dataview.setBigUint64(64, BigInt(value), U.LE);
  }

  get utf16Length(): bigint {
    return this.dataview.getBigUint64(72, U.LE);
  }

  set utf16Length(value: bigint | number) {
    this.dataview.setBigUint64(72, BigInt(value), U.LE);
  }

  static from(plain: ToCompilationMessage) {
    const struct = new CompilationMessage();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.message !== undefined) struct.message = plain.message;
    if (plain.type !== undefined) struct.type = plain.type;
    if (plain.lineNum !== undefined) struct.lineNum = plain.lineNum;
    if (plain.linePos !== undefined) struct.linePos = plain.linePos;
    if (plain.offset !== undefined) struct.offset = plain.offset;
    if (plain.length !== undefined) struct.length = plain.length;
    if (plain.utf16LinePos !== undefined) {
      struct.utf16LinePos = plain.utf16LinePos;
    }
    if (plain.utf16Offset !== undefined) struct.utf16Offset = plain.utf16Offset;
    if (plain.utf16Length !== undefined) struct.utf16Length = plain.utf16Length;
    return struct;
  }
  set(plain: ToCompilationMessage) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.message !== undefined) this.message = plain.message;
    if (plain.type !== undefined) this.type = plain.type;
    if (plain.lineNum !== undefined) this.lineNum = plain.lineNum;
    if (plain.linePos !== undefined) this.linePos = plain.linePos;
    if (plain.offset !== undefined) this.offset = plain.offset;
    if (plain.length !== undefined) this.length = plain.length;
    if (plain.utf16LinePos !== undefined) {
      this.utf16LinePos = plain.utf16LinePos;
    }
    if (plain.utf16Offset !== undefined) this.utf16Offset = plain.utf16Offset;
    if (plain.utf16Length !== undefined) this.utf16Length = plain.utf16Length;
  }
}

export type ToComputePassTimestampWrite = undefined | {
  querySet?: Deno.PointerValue | QuerySet;
  queryIndex?: number;
  location?: ComputePassTimestampLocation;
};

export class ComputePassTimestampWrite extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get querySet(): QuerySet {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return new QuerySet(ptr);
  }

  set querySet(value: Deno.PointerValue | QuerySet) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get queryIndex(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set queryIndex(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get location(): ComputePassTimestampLocation {
    return this.dataview.getUint32(12, U.LE) as ComputePassTimestampLocation;
  }

  set location(value: ComputePassTimestampLocation) {
    this.dataview.setUint32(12, value, U.LE);
  }

  static from(plain: ToComputePassTimestampWrite) {
    const struct = new ComputePassTimestampWrite();
    if (plain === undefined) return struct;
    if (plain.querySet !== undefined) struct.querySet = plain.querySet;
    if (plain.queryIndex !== undefined) struct.queryIndex = plain.queryIndex;
    if (plain.location !== undefined) struct.location = plain.location;
    return struct;
  }
  set(plain: ToComputePassTimestampWrite) {
    if (plain === undefined) return;
    if (plain.querySet !== undefined) this.querySet = plain.querySet;
    if (plain.queryIndex !== undefined) this.queryIndex = plain.queryIndex;
    if (plain.location !== undefined) this.location = plain.location;
  }
}

export type ToConstantEntry = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  key?: Deno.PointerValue;
  value?: number;
};

export class ConstantEntry extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get key(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set key(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get value(): number {
    return this.dataview.getFloat64(16, U.LE);
  }

  set value(value: number) {
    this.dataview.setFloat64(16, value, U.LE);
  }

  static from(plain: ToConstantEntry) {
    const struct = new ConstantEntry();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.key !== undefined) struct.key = plain.key;
    if (plain.value !== undefined) struct.value = plain.value;
    return struct;
  }
  set(plain: ToConstantEntry) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.key !== undefined) this.key = plain.key;
    if (plain.value !== undefined) this.value = plain.value;
  }
}

export type ToExtent3D = undefined | {
  width?: number;
  height?: number;
  depthOrArrayLayers?: number;
};

export class Extent3D extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(12));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(12),
        );
      }
    }
  }

  get width(): number {
    return this.dataview.getUint32(0, U.LE);
  }

  set width(value: number) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get height(): number {
    return this.dataview.getUint32(4, U.LE);
  }

  set height(value: number) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get depthOrArrayLayers(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set depthOrArrayLayers(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToExtent3D) {
    const struct = new Extent3D();
    if (plain === undefined) return struct;
    if (plain.width !== undefined) struct.width = plain.width;
    if (plain.height !== undefined) struct.height = plain.height;
    if (plain.depthOrArrayLayers !== undefined) {
      struct.depthOrArrayLayers = plain.depthOrArrayLayers;
    }
    return struct;
  }
  set(plain: ToExtent3D) {
    if (plain === undefined) return;
    if (plain.width !== undefined) this.width = plain.width;
    if (plain.height !== undefined) this.height = plain.height;
    if (plain.depthOrArrayLayers !== undefined) {
      this.depthOrArrayLayers = plain.depthOrArrayLayers;
    }
  }
}

export type ToInstanceDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
};

export class InstanceDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(8));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(8),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToInstanceDescriptor) {
    const struct = new InstanceDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    return struct;
  }
  set(plain: ToInstanceDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
  }
}

export type ToLimits = undefined | {
  maxTextureDimension1D?: number;
  maxTextureDimension2D?: number;
  maxTextureDimension3D?: number;
  maxTextureArrayLayers?: number;
  maxBindGroups?: number;
  maxBindingsPerBindGroup?: number;
  maxDynamicUniformBuffersPerPipelineLayout?: number;
  maxDynamicStorageBuffersPerPipelineLayout?: number;
  maxSampledTexturesPerShaderStage?: number;
  maxSamplersPerShaderStage?: number;
  maxStorageBuffersPerShaderStage?: number;
  maxStorageTexturesPerShaderStage?: number;
  maxUniformBuffersPerShaderStage?: number;
  maxUniformBufferBindingSize?: bigint | number;
  maxStorageBufferBindingSize?: bigint | number;
  minUniformBufferOffsetAlignment?: number;
  minStorageBufferOffsetAlignment?: number;
  maxVertexBuffers?: number;
  maxBufferSize?: bigint | number;
  maxVertexAttributes?: number;
  maxVertexBufferArrayStride?: number;
  maxInterStageShaderComponents?: number;
  maxInterStageShaderVariables?: number;
  maxColorAttachments?: number;
  maxColorAttachmentBytesPerSample?: number;
  maxComputeWorkgroupStorageSize?: number;
  maxComputeInvocationsPerWorkgroup?: number;
  maxComputeWorkgroupSizeX?: number;
  maxComputeWorkgroupSizeY?: number;
  maxComputeWorkgroupSizeZ?: number;
  maxComputeWorkgroupsPerDimension?: number;
};

export class Limits extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(144));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(144),
        );
      }
    }
  }

  get maxTextureDimension1D(): number {
    return this.dataview.getUint32(0, U.LE);
  }

  set maxTextureDimension1D(value: number) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get maxTextureDimension2D(): number {
    return this.dataview.getUint32(4, U.LE);
  }

  set maxTextureDimension2D(value: number) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get maxTextureDimension3D(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set maxTextureDimension3D(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get maxTextureArrayLayers(): number {
    return this.dataview.getUint32(12, U.LE);
  }

  set maxTextureArrayLayers(value: number) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get maxBindGroups(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set maxBindGroups(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get maxBindingsPerBindGroup(): number {
    return this.dataview.getUint32(20, U.LE);
  }

  set maxBindingsPerBindGroup(value: number) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get maxDynamicUniformBuffersPerPipelineLayout(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set maxDynamicUniformBuffersPerPipelineLayout(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  get maxDynamicStorageBuffersPerPipelineLayout(): number {
    return this.dataview.getUint32(28, U.LE);
  }

  set maxDynamicStorageBuffersPerPipelineLayout(value: number) {
    this.dataview.setUint32(28, value, U.LE);
  }

  get maxSampledTexturesPerShaderStage(): number {
    return this.dataview.getUint32(32, U.LE);
  }

  set maxSampledTexturesPerShaderStage(value: number) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get maxSamplersPerShaderStage(): number {
    return this.dataview.getUint32(36, U.LE);
  }

  set maxSamplersPerShaderStage(value: number) {
    this.dataview.setUint32(36, value, U.LE);
  }

  get maxStorageBuffersPerShaderStage(): number {
    return this.dataview.getUint32(40, U.LE);
  }

  set maxStorageBuffersPerShaderStage(value: number) {
    this.dataview.setUint32(40, value, U.LE);
  }

  get maxStorageTexturesPerShaderStage(): number {
    return this.dataview.getUint32(44, U.LE);
  }

  set maxStorageTexturesPerShaderStage(value: number) {
    this.dataview.setUint32(44, value, U.LE);
  }

  get maxUniformBuffersPerShaderStage(): number {
    return this.dataview.getUint32(48, U.LE);
  }

  set maxUniformBuffersPerShaderStage(value: number) {
    this.dataview.setUint32(48, value, U.LE);
  }

  get maxUniformBufferBindingSize(): bigint {
    return this.dataview.getBigUint64(56, U.LE);
  }

  set maxUniformBufferBindingSize(value: bigint | number) {
    this.dataview.setBigUint64(56, BigInt(value), U.LE);
  }

  get maxStorageBufferBindingSize(): bigint {
    return this.dataview.getBigUint64(64, U.LE);
  }

  set maxStorageBufferBindingSize(value: bigint | number) {
    this.dataview.setBigUint64(64, BigInt(value), U.LE);
  }

  get minUniformBufferOffsetAlignment(): number {
    return this.dataview.getUint32(72, U.LE);
  }

  set minUniformBufferOffsetAlignment(value: number) {
    this.dataview.setUint32(72, value, U.LE);
  }

  get minStorageBufferOffsetAlignment(): number {
    return this.dataview.getUint32(76, U.LE);
  }

  set minStorageBufferOffsetAlignment(value: number) {
    this.dataview.setUint32(76, value, U.LE);
  }

  get maxVertexBuffers(): number {
    return this.dataview.getUint32(80, U.LE);
  }

  set maxVertexBuffers(value: number) {
    this.dataview.setUint32(80, value, U.LE);
  }

  get maxBufferSize(): bigint {
    return this.dataview.getBigUint64(88, U.LE);
  }

  set maxBufferSize(value: bigint | number) {
    this.dataview.setBigUint64(88, BigInt(value), U.LE);
  }

  get maxVertexAttributes(): number {
    return this.dataview.getUint32(96, U.LE);
  }

  set maxVertexAttributes(value: number) {
    this.dataview.setUint32(96, value, U.LE);
  }

  get maxVertexBufferArrayStride(): number {
    return this.dataview.getUint32(100, U.LE);
  }

  set maxVertexBufferArrayStride(value: number) {
    this.dataview.setUint32(100, value, U.LE);
  }

  get maxInterStageShaderComponents(): number {
    return this.dataview.getUint32(104, U.LE);
  }

  set maxInterStageShaderComponents(value: number) {
    this.dataview.setUint32(104, value, U.LE);
  }

  get maxInterStageShaderVariables(): number {
    return this.dataview.getUint32(108, U.LE);
  }

  set maxInterStageShaderVariables(value: number) {
    this.dataview.setUint32(108, value, U.LE);
  }

  get maxColorAttachments(): number {
    return this.dataview.getUint32(112, U.LE);
  }

  set maxColorAttachments(value: number) {
    this.dataview.setUint32(112, value, U.LE);
  }

  get maxColorAttachmentBytesPerSample(): number {
    return this.dataview.getUint32(116, U.LE);
  }

  set maxColorAttachmentBytesPerSample(value: number) {
    this.dataview.setUint32(116, value, U.LE);
  }

  get maxComputeWorkgroupStorageSize(): number {
    return this.dataview.getUint32(120, U.LE);
  }

  set maxComputeWorkgroupStorageSize(value: number) {
    this.dataview.setUint32(120, value, U.LE);
  }

  get maxComputeInvocationsPerWorkgroup(): number {
    return this.dataview.getUint32(124, U.LE);
  }

  set maxComputeInvocationsPerWorkgroup(value: number) {
    this.dataview.setUint32(124, value, U.LE);
  }

  get maxComputeWorkgroupSizeX(): number {
    return this.dataview.getUint32(128, U.LE);
  }

  set maxComputeWorkgroupSizeX(value: number) {
    this.dataview.setUint32(128, value, U.LE);
  }

  get maxComputeWorkgroupSizeY(): number {
    return this.dataview.getUint32(132, U.LE);
  }

  set maxComputeWorkgroupSizeY(value: number) {
    this.dataview.setUint32(132, value, U.LE);
  }

  get maxComputeWorkgroupSizeZ(): number {
    return this.dataview.getUint32(136, U.LE);
  }

  set maxComputeWorkgroupSizeZ(value: number) {
    this.dataview.setUint32(136, value, U.LE);
  }

  get maxComputeWorkgroupsPerDimension(): number {
    return this.dataview.getUint32(140, U.LE);
  }

  set maxComputeWorkgroupsPerDimension(value: number) {
    this.dataview.setUint32(140, value, U.LE);
  }

  static from(plain: ToLimits) {
    const struct = new Limits();
    if (plain === undefined) return struct;
    if (plain.maxTextureDimension1D !== undefined) {
      struct.maxTextureDimension1D = plain.maxTextureDimension1D;
    }
    if (plain.maxTextureDimension2D !== undefined) {
      struct.maxTextureDimension2D = plain.maxTextureDimension2D;
    }
    if (plain.maxTextureDimension3D !== undefined) {
      struct.maxTextureDimension3D = plain.maxTextureDimension3D;
    }
    if (plain.maxTextureArrayLayers !== undefined) {
      struct.maxTextureArrayLayers = plain.maxTextureArrayLayers;
    }
    if (plain.maxBindGroups !== undefined) {
      struct.maxBindGroups = plain.maxBindGroups;
    }
    if (plain.maxBindingsPerBindGroup !== undefined) {
      struct.maxBindingsPerBindGroup = plain.maxBindingsPerBindGroup;
    }
    if (plain.maxDynamicUniformBuffersPerPipelineLayout !== undefined) {
      struct.maxDynamicUniformBuffersPerPipelineLayout =
        plain.maxDynamicUniformBuffersPerPipelineLayout;
    }
    if (plain.maxDynamicStorageBuffersPerPipelineLayout !== undefined) {
      struct.maxDynamicStorageBuffersPerPipelineLayout =
        plain.maxDynamicStorageBuffersPerPipelineLayout;
    }
    if (plain.maxSampledTexturesPerShaderStage !== undefined) {
      struct.maxSampledTexturesPerShaderStage =
        plain.maxSampledTexturesPerShaderStage;
    }
    if (plain.maxSamplersPerShaderStage !== undefined) {
      struct.maxSamplersPerShaderStage = plain.maxSamplersPerShaderStage;
    }
    if (plain.maxStorageBuffersPerShaderStage !== undefined) {
      struct.maxStorageBuffersPerShaderStage =
        plain.maxStorageBuffersPerShaderStage;
    }
    if (plain.maxStorageTexturesPerShaderStage !== undefined) {
      struct.maxStorageTexturesPerShaderStage =
        plain.maxStorageTexturesPerShaderStage;
    }
    if (plain.maxUniformBuffersPerShaderStage !== undefined) {
      struct.maxUniformBuffersPerShaderStage =
        plain.maxUniformBuffersPerShaderStage;
    }
    if (plain.maxUniformBufferBindingSize !== undefined) {
      struct.maxUniformBufferBindingSize = plain.maxUniformBufferBindingSize;
    }
    if (plain.maxStorageBufferBindingSize !== undefined) {
      struct.maxStorageBufferBindingSize = plain.maxStorageBufferBindingSize;
    }
    if (plain.minUniformBufferOffsetAlignment !== undefined) {
      struct.minUniformBufferOffsetAlignment =
        plain.minUniformBufferOffsetAlignment;
    }
    if (plain.minStorageBufferOffsetAlignment !== undefined) {
      struct.minStorageBufferOffsetAlignment =
        plain.minStorageBufferOffsetAlignment;
    }
    if (plain.maxVertexBuffers !== undefined) {
      struct.maxVertexBuffers = plain.maxVertexBuffers;
    }
    if (plain.maxBufferSize !== undefined) {
      struct.maxBufferSize = plain.maxBufferSize;
    }
    if (plain.maxVertexAttributes !== undefined) {
      struct.maxVertexAttributes = plain.maxVertexAttributes;
    }
    if (plain.maxVertexBufferArrayStride !== undefined) {
      struct.maxVertexBufferArrayStride = plain.maxVertexBufferArrayStride;
    }
    if (plain.maxInterStageShaderComponents !== undefined) {
      struct.maxInterStageShaderComponents =
        plain.maxInterStageShaderComponents;
    }
    if (plain.maxInterStageShaderVariables !== undefined) {
      struct.maxInterStageShaderVariables = plain.maxInterStageShaderVariables;
    }
    if (plain.maxColorAttachments !== undefined) {
      struct.maxColorAttachments = plain.maxColorAttachments;
    }
    if (plain.maxColorAttachmentBytesPerSample !== undefined) {
      struct.maxColorAttachmentBytesPerSample =
        plain.maxColorAttachmentBytesPerSample;
    }
    if (plain.maxComputeWorkgroupStorageSize !== undefined) {
      struct.maxComputeWorkgroupStorageSize =
        plain.maxComputeWorkgroupStorageSize;
    }
    if (plain.maxComputeInvocationsPerWorkgroup !== undefined) {
      struct.maxComputeInvocationsPerWorkgroup =
        plain.maxComputeInvocationsPerWorkgroup;
    }
    if (plain.maxComputeWorkgroupSizeX !== undefined) {
      struct.maxComputeWorkgroupSizeX = plain.maxComputeWorkgroupSizeX;
    }
    if (plain.maxComputeWorkgroupSizeY !== undefined) {
      struct.maxComputeWorkgroupSizeY = plain.maxComputeWorkgroupSizeY;
    }
    if (plain.maxComputeWorkgroupSizeZ !== undefined) {
      struct.maxComputeWorkgroupSizeZ = plain.maxComputeWorkgroupSizeZ;
    }
    if (plain.maxComputeWorkgroupsPerDimension !== undefined) {
      struct.maxComputeWorkgroupsPerDimension =
        plain.maxComputeWorkgroupsPerDimension;
    }
    return struct;
  }
  set(plain: ToLimits) {
    if (plain === undefined) return;
    if (plain.maxTextureDimension1D !== undefined) {
      this.maxTextureDimension1D = plain.maxTextureDimension1D;
    }
    if (plain.maxTextureDimension2D !== undefined) {
      this.maxTextureDimension2D = plain.maxTextureDimension2D;
    }
    if (plain.maxTextureDimension3D !== undefined) {
      this.maxTextureDimension3D = plain.maxTextureDimension3D;
    }
    if (plain.maxTextureArrayLayers !== undefined) {
      this.maxTextureArrayLayers = plain.maxTextureArrayLayers;
    }
    if (plain.maxBindGroups !== undefined) {
      this.maxBindGroups = plain.maxBindGroups;
    }
    if (plain.maxBindingsPerBindGroup !== undefined) {
      this.maxBindingsPerBindGroup = plain.maxBindingsPerBindGroup;
    }
    if (plain.maxDynamicUniformBuffersPerPipelineLayout !== undefined) {
      this.maxDynamicUniformBuffersPerPipelineLayout =
        plain.maxDynamicUniformBuffersPerPipelineLayout;
    }
    if (plain.maxDynamicStorageBuffersPerPipelineLayout !== undefined) {
      this.maxDynamicStorageBuffersPerPipelineLayout =
        plain.maxDynamicStorageBuffersPerPipelineLayout;
    }
    if (plain.maxSampledTexturesPerShaderStage !== undefined) {
      this.maxSampledTexturesPerShaderStage =
        plain.maxSampledTexturesPerShaderStage;
    }
    if (plain.maxSamplersPerShaderStage !== undefined) {
      this.maxSamplersPerShaderStage = plain.maxSamplersPerShaderStage;
    }
    if (plain.maxStorageBuffersPerShaderStage !== undefined) {
      this.maxStorageBuffersPerShaderStage =
        plain.maxStorageBuffersPerShaderStage;
    }
    if (plain.maxStorageTexturesPerShaderStage !== undefined) {
      this.maxStorageTexturesPerShaderStage =
        plain.maxStorageTexturesPerShaderStage;
    }
    if (plain.maxUniformBuffersPerShaderStage !== undefined) {
      this.maxUniformBuffersPerShaderStage =
        plain.maxUniformBuffersPerShaderStage;
    }
    if (plain.maxUniformBufferBindingSize !== undefined) {
      this.maxUniformBufferBindingSize = plain.maxUniformBufferBindingSize;
    }
    if (plain.maxStorageBufferBindingSize !== undefined) {
      this.maxStorageBufferBindingSize = plain.maxStorageBufferBindingSize;
    }
    if (plain.minUniformBufferOffsetAlignment !== undefined) {
      this.minUniformBufferOffsetAlignment =
        plain.minUniformBufferOffsetAlignment;
    }
    if (plain.minStorageBufferOffsetAlignment !== undefined) {
      this.minStorageBufferOffsetAlignment =
        plain.minStorageBufferOffsetAlignment;
    }
    if (plain.maxVertexBuffers !== undefined) {
      this.maxVertexBuffers = plain.maxVertexBuffers;
    }
    if (plain.maxBufferSize !== undefined) {
      this.maxBufferSize = plain.maxBufferSize;
    }
    if (plain.maxVertexAttributes !== undefined) {
      this.maxVertexAttributes = plain.maxVertexAttributes;
    }
    if (plain.maxVertexBufferArrayStride !== undefined) {
      this.maxVertexBufferArrayStride = plain.maxVertexBufferArrayStride;
    }
    if (plain.maxInterStageShaderComponents !== undefined) {
      this.maxInterStageShaderComponents = plain.maxInterStageShaderComponents;
    }
    if (plain.maxInterStageShaderVariables !== undefined) {
      this.maxInterStageShaderVariables = plain.maxInterStageShaderVariables;
    }
    if (plain.maxColorAttachments !== undefined) {
      this.maxColorAttachments = plain.maxColorAttachments;
    }
    if (plain.maxColorAttachmentBytesPerSample !== undefined) {
      this.maxColorAttachmentBytesPerSample =
        plain.maxColorAttachmentBytesPerSample;
    }
    if (plain.maxComputeWorkgroupStorageSize !== undefined) {
      this.maxComputeWorkgroupStorageSize =
        plain.maxComputeWorkgroupStorageSize;
    }
    if (plain.maxComputeInvocationsPerWorkgroup !== undefined) {
      this.maxComputeInvocationsPerWorkgroup =
        plain.maxComputeInvocationsPerWorkgroup;
    }
    if (plain.maxComputeWorkgroupSizeX !== undefined) {
      this.maxComputeWorkgroupSizeX = plain.maxComputeWorkgroupSizeX;
    }
    if (plain.maxComputeWorkgroupSizeY !== undefined) {
      this.maxComputeWorkgroupSizeY = plain.maxComputeWorkgroupSizeY;
    }
    if (plain.maxComputeWorkgroupSizeZ !== undefined) {
      this.maxComputeWorkgroupSizeZ = plain.maxComputeWorkgroupSizeZ;
    }
    if (plain.maxComputeWorkgroupsPerDimension !== undefined) {
      this.maxComputeWorkgroupsPerDimension =
        plain.maxComputeWorkgroupsPerDimension;
    }
  }
}

export type ToMultisampleState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  count?: number;
  mask?: number;
  alphaToCoverageEnabled?: boolean | number | bigint;
};

export class MultisampleState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get count(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set count(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get mask(): number {
    return this.dataview.getUint32(12, U.LE);
  }

  set mask(value: number) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get alphaToCoverageEnabled(): boolean {
    return this.dataview.getUint8(16) == 1;
  }

  set alphaToCoverageEnabled(value: boolean | number | bigint) {
    this.dataview.setUint8(16, value ? 1 : 0);
  }

  static from(plain: ToMultisampleState) {
    const struct = new MultisampleState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.count !== undefined) struct.count = plain.count;
    if (plain.mask !== undefined) struct.mask = plain.mask;
    if (plain.alphaToCoverageEnabled !== undefined) {
      struct.alphaToCoverageEnabled = plain.alphaToCoverageEnabled;
    }
    return struct;
  }
  set(plain: ToMultisampleState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.count !== undefined) this.count = plain.count;
    if (plain.mask !== undefined) this.mask = plain.mask;
    if (plain.alphaToCoverageEnabled !== undefined) {
      this.alphaToCoverageEnabled = plain.alphaToCoverageEnabled;
    }
  }
}

export type ToOrigin3D = undefined | {
  x?: number;
  y?: number;
  z?: number;
};

export class Origin3D extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(12));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(12),
        );
      }
    }
  }

  get x(): number {
    return this.dataview.getUint32(0, U.LE);
  }

  set x(value: number) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get y(): number {
    return this.dataview.getUint32(4, U.LE);
  }

  set y(value: number) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get z(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set z(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToOrigin3D) {
    const struct = new Origin3D();
    if (plain === undefined) return struct;
    if (plain.x !== undefined) struct.x = plain.x;
    if (plain.y !== undefined) struct.y = plain.y;
    if (plain.z !== undefined) struct.z = plain.z;
    return struct;
  }
  set(plain: ToOrigin3D) {
    if (plain === undefined) return;
    if (plain.x !== undefined) this.x = plain.x;
    if (plain.y !== undefined) this.y = plain.y;
    if (plain.z !== undefined) this.z = plain.z;
  }
}

export type ToPipelineLayoutDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  bindGroupLayoutCount?: bigint | number;
  bindGroupLayouts?: Deno.PointerValue;
};

export class PipelineLayoutDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get bindGroupLayoutCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set bindGroupLayoutCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get bindGroupLayouts(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set bindGroupLayouts(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToPipelineLayoutDescriptor) {
    const struct = new PipelineLayoutDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.bindGroupLayoutCount !== undefined) {
      struct.bindGroupLayoutCount = plain.bindGroupLayoutCount;
    }
    if (plain.bindGroupLayouts !== undefined) {
      struct.bindGroupLayouts = plain.bindGroupLayouts;
    }
    return struct;
  }
  set(plain: ToPipelineLayoutDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.bindGroupLayoutCount !== undefined) {
      this.bindGroupLayoutCount = plain.bindGroupLayoutCount;
    }
    if (plain.bindGroupLayouts !== undefined) {
      this.bindGroupLayouts = plain.bindGroupLayouts;
    }
  }
}

export type ToPrimitiveDepthClipControl = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  unclippedDepth?: boolean | number | bigint;
};

export class PrimitiveDepthClipControl extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.PrimitiveDepthClipControl;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get unclippedDepth(): boolean {
    return this.dataview.getUint8(16) == 1;
  }

  set unclippedDepth(value: boolean | number | bigint) {
    this.dataview.setUint8(16, value ? 1 : 0);
  }

  static from(plain: ToPrimitiveDepthClipControl) {
    const struct = new PrimitiveDepthClipControl();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.unclippedDepth !== undefined) {
      struct.unclippedDepth = plain.unclippedDepth;
    }
    return struct;
  }
  set(plain: ToPrimitiveDepthClipControl) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.unclippedDepth !== undefined) {
      this.unclippedDepth = plain.unclippedDepth;
    }
  }
}

export type ToPrimitiveState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  topology?: PrimitiveTopology;
  stripIndexFormat?: IndexFormat;
  frontFace?: FrontFace;
  cullMode?: CullMode;
};

export class PrimitiveState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get topology(): PrimitiveTopology {
    return this.dataview.getUint32(8, U.LE) as PrimitiveTopology;
  }

  set topology(value: PrimitiveTopology) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get stripIndexFormat(): IndexFormat {
    return this.dataview.getUint32(12, U.LE) as IndexFormat;
  }

  set stripIndexFormat(value: IndexFormat) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get frontFace(): FrontFace {
    return this.dataview.getUint32(16, U.LE) as FrontFace;
  }

  set frontFace(value: FrontFace) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get cullMode(): CullMode {
    return this.dataview.getUint32(20, U.LE) as CullMode;
  }

  set cullMode(value: CullMode) {
    this.dataview.setUint32(20, value, U.LE);
  }

  static from(plain: ToPrimitiveState) {
    const struct = new PrimitiveState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.topology !== undefined) struct.topology = plain.topology;
    if (plain.stripIndexFormat !== undefined) {
      struct.stripIndexFormat = plain.stripIndexFormat;
    }
    if (plain.frontFace !== undefined) struct.frontFace = plain.frontFace;
    if (plain.cullMode !== undefined) struct.cullMode = plain.cullMode;
    return struct;
  }
  set(plain: ToPrimitiveState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.topology !== undefined) this.topology = plain.topology;
    if (plain.stripIndexFormat !== undefined) {
      this.stripIndexFormat = plain.stripIndexFormat;
    }
    if (plain.frontFace !== undefined) this.frontFace = plain.frontFace;
    if (plain.cullMode !== undefined) this.cullMode = plain.cullMode;
  }
}

export type ToQuerySetDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  type?: QueryType;
  count?: number;
  pipelineStatistics?: Deno.PointerValue;
  pipelineStatisticsCount?: bigint | number;
};

export class QuerySetDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get type(): QueryType {
    return this.dataview.getUint32(16, U.LE) as QueryType;
  }

  set type(value: QueryType) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get count(): number {
    return this.dataview.getUint32(20, U.LE);
  }

  set count(value: number) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get pipelineStatistics(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set pipelineStatistics(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get pipelineStatisticsCount(): bigint {
    return this.dataview.getBigUint64(32, U.LE);
  }

  set pipelineStatisticsCount(value: bigint | number) {
    this.dataview.setBigUint64(32, BigInt(value), U.LE);
  }

  static from(plain: ToQuerySetDescriptor) {
    const struct = new QuerySetDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.type !== undefined) struct.type = plain.type;
    if (plain.count !== undefined) struct.count = plain.count;
    if (plain.pipelineStatistics !== undefined) {
      struct.pipelineStatistics = plain.pipelineStatistics;
    }
    if (plain.pipelineStatisticsCount !== undefined) {
      struct.pipelineStatisticsCount = plain.pipelineStatisticsCount;
    }
    return struct;
  }
  set(plain: ToQuerySetDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.type !== undefined) this.type = plain.type;
    if (plain.count !== undefined) this.count = plain.count;
    if (plain.pipelineStatistics !== undefined) {
      this.pipelineStatistics = plain.pipelineStatistics;
    }
    if (plain.pipelineStatisticsCount !== undefined) {
      this.pipelineStatisticsCount = plain.pipelineStatisticsCount;
    }
  }
}

export type ToQueueDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
};

export class QueueDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToQueueDescriptor) {
    const struct = new QueueDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    return struct;
  }
  set(plain: ToQueueDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
  }
}

export type ToRenderBundleDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
};

export class RenderBundleDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToRenderBundleDescriptor) {
    const struct = new RenderBundleDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    return struct;
  }
  set(plain: ToRenderBundleDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
  }
}

export type ToRenderBundleEncoderDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  colorFormatsCount?: bigint | number;
  colorFormats?: Deno.PointerValue;
  depthStencilFormat?: TextureFormat;
  sampleCount?: number;
  depthReadOnly?: boolean | number | bigint;
  stencilReadOnly?: boolean | number | bigint;
};

export class RenderBundleEncoderDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(48));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(48),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get colorFormatsCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set colorFormatsCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get colorFormats(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set colorFormats(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get depthStencilFormat(): TextureFormat {
    return this.dataview.getUint32(32, U.LE) as TextureFormat;
  }

  set depthStencilFormat(value: TextureFormat) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get sampleCount(): number {
    return this.dataview.getUint32(36, U.LE);
  }

  set sampleCount(value: number) {
    this.dataview.setUint32(36, value, U.LE);
  }

  get depthReadOnly(): boolean {
    return this.dataview.getUint8(40) == 1;
  }

  set depthReadOnly(value: boolean | number | bigint) {
    this.dataview.setUint8(40, value ? 1 : 0);
  }

  get stencilReadOnly(): boolean {
    return this.dataview.getUint8(41) == 1;
  }

  set stencilReadOnly(value: boolean | number | bigint) {
    this.dataview.setUint8(41, value ? 1 : 0);
  }

  static from(plain: ToRenderBundleEncoderDescriptor) {
    const struct = new RenderBundleEncoderDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.colorFormatsCount !== undefined) {
      struct.colorFormatsCount = plain.colorFormatsCount;
    }
    if (plain.colorFormats !== undefined) {
      struct.colorFormats = plain.colorFormats;
    }
    if (plain.depthStencilFormat !== undefined) {
      struct.depthStencilFormat = plain.depthStencilFormat;
    }
    if (plain.sampleCount !== undefined) struct.sampleCount = plain.sampleCount;
    if (plain.depthReadOnly !== undefined) {
      struct.depthReadOnly = plain.depthReadOnly;
    }
    if (plain.stencilReadOnly !== undefined) {
      struct.stencilReadOnly = plain.stencilReadOnly;
    }
    return struct;
  }
  set(plain: ToRenderBundleEncoderDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.colorFormatsCount !== undefined) {
      this.colorFormatsCount = plain.colorFormatsCount;
    }
    if (plain.colorFormats !== undefined) {
      this.colorFormats = plain.colorFormats;
    }
    if (plain.depthStencilFormat !== undefined) {
      this.depthStencilFormat = plain.depthStencilFormat;
    }
    if (plain.sampleCount !== undefined) this.sampleCount = plain.sampleCount;
    if (plain.depthReadOnly !== undefined) {
      this.depthReadOnly = plain.depthReadOnly;
    }
    if (plain.stencilReadOnly !== undefined) {
      this.stencilReadOnly = plain.stencilReadOnly;
    }
  }
}

export type ToRenderPassDepthStencilAttachment = undefined | {
  view?: Deno.PointerValue | TextureView;
  depthLoadOp?: LoadOp;
  depthStoreOp?: StoreOp;
  depthClearValue?: number;
  depthReadOnly?: boolean | number | bigint;
  stencilLoadOp?: LoadOp;
  stencilStoreOp?: StoreOp;
  stencilClearValue?: number;
  stencilReadOnly?: boolean | number | bigint;
};

export class RenderPassDepthStencilAttachment extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get view(): TextureView {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return new TextureView(ptr);
  }

  set view(value: Deno.PointerValue | TextureView) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get depthLoadOp(): LoadOp {
    return this.dataview.getUint32(8, U.LE) as LoadOp;
  }

  set depthLoadOp(value: LoadOp) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get depthStoreOp(): StoreOp {
    return this.dataview.getUint32(12, U.LE) as StoreOp;
  }

  set depthStoreOp(value: StoreOp) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get depthClearValue(): number {
    return this.dataview.getFloat32(16, U.LE);
  }

  set depthClearValue(value: number) {
    this.dataview.setFloat32(16, value, U.LE);
  }

  get depthReadOnly(): boolean {
    return this.dataview.getUint8(20) == 1;
  }

  set depthReadOnly(value: boolean | number | bigint) {
    this.dataview.setUint8(20, value ? 1 : 0);
  }

  get stencilLoadOp(): LoadOp {
    return this.dataview.getUint32(24, U.LE) as LoadOp;
  }

  set stencilLoadOp(value: LoadOp) {
    this.dataview.setUint32(24, value, U.LE);
  }

  get stencilStoreOp(): StoreOp {
    return this.dataview.getUint32(28, U.LE) as StoreOp;
  }

  set stencilStoreOp(value: StoreOp) {
    this.dataview.setUint32(28, value, U.LE);
  }

  get stencilClearValue(): number {
    return this.dataview.getUint32(32, U.LE);
  }

  set stencilClearValue(value: number) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get stencilReadOnly(): boolean {
    return this.dataview.getUint8(36) == 1;
  }

  set stencilReadOnly(value: boolean | number | bigint) {
    this.dataview.setUint8(36, value ? 1 : 0);
  }

  static from(plain: ToRenderPassDepthStencilAttachment) {
    const struct = new RenderPassDepthStencilAttachment();
    if (plain === undefined) return struct;
    if (plain.view !== undefined) struct.view = plain.view;
    if (plain.depthLoadOp !== undefined) struct.depthLoadOp = plain.depthLoadOp;
    if (plain.depthStoreOp !== undefined) {
      struct.depthStoreOp = plain.depthStoreOp;
    }
    if (plain.depthClearValue !== undefined) {
      struct.depthClearValue = plain.depthClearValue;
    }
    if (plain.depthReadOnly !== undefined) {
      struct.depthReadOnly = plain.depthReadOnly;
    }
    if (plain.stencilLoadOp !== undefined) {
      struct.stencilLoadOp = plain.stencilLoadOp;
    }
    if (plain.stencilStoreOp !== undefined) {
      struct.stencilStoreOp = plain.stencilStoreOp;
    }
    if (plain.stencilClearValue !== undefined) {
      struct.stencilClearValue = plain.stencilClearValue;
    }
    if (plain.stencilReadOnly !== undefined) {
      struct.stencilReadOnly = plain.stencilReadOnly;
    }
    return struct;
  }
  set(plain: ToRenderPassDepthStencilAttachment) {
    if (plain === undefined) return;
    if (plain.view !== undefined) this.view = plain.view;
    if (plain.depthLoadOp !== undefined) this.depthLoadOp = plain.depthLoadOp;
    if (plain.depthStoreOp !== undefined) {
      this.depthStoreOp = plain.depthStoreOp;
    }
    if (plain.depthClearValue !== undefined) {
      this.depthClearValue = plain.depthClearValue;
    }
    if (plain.depthReadOnly !== undefined) {
      this.depthReadOnly = plain.depthReadOnly;
    }
    if (plain.stencilLoadOp !== undefined) {
      this.stencilLoadOp = plain.stencilLoadOp;
    }
    if (plain.stencilStoreOp !== undefined) {
      this.stencilStoreOp = plain.stencilStoreOp;
    }
    if (plain.stencilClearValue !== undefined) {
      this.stencilClearValue = plain.stencilClearValue;
    }
    if (plain.stencilReadOnly !== undefined) {
      this.stencilReadOnly = plain.stencilReadOnly;
    }
  }
}

export type ToRenderPassDescriptorMaxDrawCount = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  maxDrawCount?: bigint | number;
};

export class RenderPassDescriptorMaxDrawCount extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.RenderPassDescriptorMaxDrawCount;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get maxDrawCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set maxDrawCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  static from(plain: ToRenderPassDescriptorMaxDrawCount) {
    const struct = new RenderPassDescriptorMaxDrawCount();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.maxDrawCount !== undefined) {
      struct.maxDrawCount = plain.maxDrawCount;
    }
    return struct;
  }
  set(plain: ToRenderPassDescriptorMaxDrawCount) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.maxDrawCount !== undefined) {
      this.maxDrawCount = plain.maxDrawCount;
    }
  }
}

export type ToRenderPassTimestampWrite = undefined | {
  querySet?: Deno.PointerValue | QuerySet;
  queryIndex?: number;
  location?: RenderPassTimestampLocation;
};

export class RenderPassTimestampWrite extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get querySet(): QuerySet {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return new QuerySet(ptr);
  }

  set querySet(value: Deno.PointerValue | QuerySet) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get queryIndex(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set queryIndex(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get location(): RenderPassTimestampLocation {
    return this.dataview.getUint32(12, U.LE) as RenderPassTimestampLocation;
  }

  set location(value: RenderPassTimestampLocation) {
    this.dataview.setUint32(12, value, U.LE);
  }

  static from(plain: ToRenderPassTimestampWrite) {
    const struct = new RenderPassTimestampWrite();
    if (plain === undefined) return struct;
    if (plain.querySet !== undefined) struct.querySet = plain.querySet;
    if (plain.queryIndex !== undefined) struct.queryIndex = plain.queryIndex;
    if (plain.location !== undefined) struct.location = plain.location;
    return struct;
  }
  set(plain: ToRenderPassTimestampWrite) {
    if (plain === undefined) return;
    if (plain.querySet !== undefined) this.querySet = plain.querySet;
    if (plain.queryIndex !== undefined) this.queryIndex = plain.queryIndex;
    if (plain.location !== undefined) this.location = plain.location;
  }
}

export type ToRequestAdapterOptions = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  compatibleSurface?: Deno.PointerValue | Surface;
  powerPreference?: PowerPreference;
  backendType?: BackendType;
  forceFallbackAdapter?: boolean | number | bigint;
};

export class RequestAdapterOptions extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get compatibleSurface(): Surface {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new Surface(ptr);
  }

  set compatibleSurface(value: Deno.PointerValue | Surface) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get powerPreference(): PowerPreference {
    return this.dataview.getUint32(16, U.LE) as PowerPreference;
  }

  set powerPreference(value: PowerPreference) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get backendType(): BackendType {
    return this.dataview.getUint32(20, U.LE) as BackendType;
  }

  set backendType(value: BackendType) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get forceFallbackAdapter(): boolean {
    return this.dataview.getUint8(24) == 1;
  }

  set forceFallbackAdapter(value: boolean | number | bigint) {
    this.dataview.setUint8(24, value ? 1 : 0);
  }

  static from(plain: ToRequestAdapterOptions) {
    const struct = new RequestAdapterOptions();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.compatibleSurface !== undefined) {
      struct.compatibleSurface = plain.compatibleSurface;
    }
    if (plain.powerPreference !== undefined) {
      struct.powerPreference = plain.powerPreference;
    }
    if (plain.backendType !== undefined) struct.backendType = plain.backendType;
    if (plain.forceFallbackAdapter !== undefined) {
      struct.forceFallbackAdapter = plain.forceFallbackAdapter;
    }
    return struct;
  }
  set(plain: ToRequestAdapterOptions) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.compatibleSurface !== undefined) {
      this.compatibleSurface = plain.compatibleSurface;
    }
    if (plain.powerPreference !== undefined) {
      this.powerPreference = plain.powerPreference;
    }
    if (plain.backendType !== undefined) this.backendType = plain.backendType;
    if (plain.forceFallbackAdapter !== undefined) {
      this.forceFallbackAdapter = plain.forceFallbackAdapter;
    }
  }
}

export type ToSamplerBindingLayout = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  type?: SamplerBindingType;
};

export class SamplerBindingLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get type(): SamplerBindingType {
    return this.dataview.getUint32(8, U.LE) as SamplerBindingType;
  }

  set type(value: SamplerBindingType) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToSamplerBindingLayout) {
    const struct = new SamplerBindingLayout();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.type !== undefined) struct.type = plain.type;
    return struct;
  }
  set(plain: ToSamplerBindingLayout) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.type !== undefined) this.type = plain.type;
  }
}

export type ToSamplerDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  addressModeU?: AddressMode;
  addressModeV?: AddressMode;
  addressModeW?: AddressMode;
  magFilter?: FilterMode;
  minFilter?: FilterMode;
  mipmapFilter?: MipmapFilterMode;
  lodMinClamp?: number;
  lodMaxClamp?: number;
  compare?: CompareFunction;
  maxAnisotropy?: number;
};

export class SamplerDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(56));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(56),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get addressModeU(): AddressMode {
    return this.dataview.getUint32(16, U.LE) as AddressMode;
  }

  set addressModeU(value: AddressMode) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get addressModeV(): AddressMode {
    return this.dataview.getUint32(20, U.LE) as AddressMode;
  }

  set addressModeV(value: AddressMode) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get addressModeW(): AddressMode {
    return this.dataview.getUint32(24, U.LE) as AddressMode;
  }

  set addressModeW(value: AddressMode) {
    this.dataview.setUint32(24, value, U.LE);
  }

  get magFilter(): FilterMode {
    return this.dataview.getUint32(28, U.LE) as FilterMode;
  }

  set magFilter(value: FilterMode) {
    this.dataview.setUint32(28, value, U.LE);
  }

  get minFilter(): FilterMode {
    return this.dataview.getUint32(32, U.LE) as FilterMode;
  }

  set minFilter(value: FilterMode) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get mipmapFilter(): MipmapFilterMode {
    return this.dataview.getUint32(36, U.LE) as MipmapFilterMode;
  }

  set mipmapFilter(value: MipmapFilterMode) {
    this.dataview.setUint32(36, value, U.LE);
  }

  get lodMinClamp(): number {
    return this.dataview.getFloat32(40, U.LE);
  }

  set lodMinClamp(value: number) {
    this.dataview.setFloat32(40, value, U.LE);
  }

  get lodMaxClamp(): number {
    return this.dataview.getFloat32(44, U.LE);
  }

  set lodMaxClamp(value: number) {
    this.dataview.setFloat32(44, value, U.LE);
  }

  get compare(): CompareFunction {
    return this.dataview.getUint32(48, U.LE) as CompareFunction;
  }

  set compare(value: CompareFunction) {
    this.dataview.setUint32(48, value, U.LE);
  }

  get maxAnisotropy(): number {
    return this.dataview.getUint16(52, U.LE);
  }

  set maxAnisotropy(value: number) {
    this.dataview.setUint16(52, value, U.LE);
  }

  static from(plain: ToSamplerDescriptor) {
    const struct = new SamplerDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.addressModeU !== undefined) {
      struct.addressModeU = plain.addressModeU;
    }
    if (plain.addressModeV !== undefined) {
      struct.addressModeV = plain.addressModeV;
    }
    if (plain.addressModeW !== undefined) {
      struct.addressModeW = plain.addressModeW;
    }
    if (plain.magFilter !== undefined) struct.magFilter = plain.magFilter;
    if (plain.minFilter !== undefined) struct.minFilter = plain.minFilter;
    if (plain.mipmapFilter !== undefined) {
      struct.mipmapFilter = plain.mipmapFilter;
    }
    if (plain.lodMinClamp !== undefined) struct.lodMinClamp = plain.lodMinClamp;
    if (plain.lodMaxClamp !== undefined) struct.lodMaxClamp = plain.lodMaxClamp;
    if (plain.compare !== undefined) struct.compare = plain.compare;
    if (plain.maxAnisotropy !== undefined) {
      struct.maxAnisotropy = plain.maxAnisotropy;
    }
    return struct;
  }
  set(plain: ToSamplerDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.addressModeU !== undefined) {
      this.addressModeU = plain.addressModeU;
    }
    if (plain.addressModeV !== undefined) {
      this.addressModeV = plain.addressModeV;
    }
    if (plain.addressModeW !== undefined) {
      this.addressModeW = plain.addressModeW;
    }
    if (plain.magFilter !== undefined) this.magFilter = plain.magFilter;
    if (plain.minFilter !== undefined) this.minFilter = plain.minFilter;
    if (plain.mipmapFilter !== undefined) {
      this.mipmapFilter = plain.mipmapFilter;
    }
    if (plain.lodMinClamp !== undefined) this.lodMinClamp = plain.lodMinClamp;
    if (plain.lodMaxClamp !== undefined) this.lodMaxClamp = plain.lodMaxClamp;
    if (plain.compare !== undefined) this.compare = plain.compare;
    if (plain.maxAnisotropy !== undefined) {
      this.maxAnisotropy = plain.maxAnisotropy;
    }
  }
}

export type ToShaderModuleCompilationHint = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  entryPoint?: Deno.PointerValue;
  layout?: Deno.PointerValue | PipelineLayout;
};

export class ShaderModuleCompilationHint extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryPoint(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set entryPoint(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get layout(): PipelineLayout {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return new PipelineLayout(ptr);
  }

  set layout(value: Deno.PointerValue | PipelineLayout) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderModuleCompilationHint) {
    const struct = new ShaderModuleCompilationHint();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.entryPoint !== undefined) struct.entryPoint = plain.entryPoint;
    if (plain.layout !== undefined) struct.layout = plain.layout;
    return struct;
  }
  set(plain: ToShaderModuleCompilationHint) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.entryPoint !== undefined) this.entryPoint = plain.entryPoint;
    if (plain.layout !== undefined) this.layout = plain.layout;
  }
}

export type ToShaderModuleSPIRVDescriptor = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  codeSize?: number;
  code?: Deno.PointerValue;
};

export class ShaderModuleSPIRVDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.ShaderModuleSPIRVDescriptor;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get codeSize(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set codeSize(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get code(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set code(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderModuleSPIRVDescriptor) {
    const struct = new ShaderModuleSPIRVDescriptor();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.codeSize !== undefined) struct.codeSize = plain.codeSize;
    if (plain.code !== undefined) struct.code = plain.code;
    return struct;
  }
  set(plain: ToShaderModuleSPIRVDescriptor) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.codeSize !== undefined) this.codeSize = plain.codeSize;
    if (plain.code !== undefined) this.code = plain.code;
  }
}

export type ToShaderModuleWGSLDescriptor = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  code?: Deno.PointerValue;
};

export class ShaderModuleWGSLDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.ShaderModuleWGSLDescriptor;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get code(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set code(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderModuleWGSLDescriptor) {
    const struct = new ShaderModuleWGSLDescriptor();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.code !== undefined) struct.code = plain.code;
    return struct;
  }
  set(plain: ToShaderModuleWGSLDescriptor) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.code !== undefined) this.code = plain.code;
  }
}

export type ToStencilFaceState = undefined | {
  compare?: CompareFunction;
  failOp?: StencilOperation;
  depthFailOp?: StencilOperation;
  passOp?: StencilOperation;
};

export class StencilFaceState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get compare(): CompareFunction {
    return this.dataview.getUint32(0, U.LE) as CompareFunction;
  }

  set compare(value: CompareFunction) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get failOp(): StencilOperation {
    return this.dataview.getUint32(4, U.LE) as StencilOperation;
  }

  set failOp(value: StencilOperation) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get depthFailOp(): StencilOperation {
    return this.dataview.getUint32(8, U.LE) as StencilOperation;
  }

  set depthFailOp(value: StencilOperation) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get passOp(): StencilOperation {
    return this.dataview.getUint32(12, U.LE) as StencilOperation;
  }

  set passOp(value: StencilOperation) {
    this.dataview.setUint32(12, value, U.LE);
  }

  static from(plain: ToStencilFaceState) {
    const struct = new StencilFaceState();
    if (plain === undefined) return struct;
    if (plain.compare !== undefined) struct.compare = plain.compare;
    if (plain.failOp !== undefined) struct.failOp = plain.failOp;
    if (plain.depthFailOp !== undefined) struct.depthFailOp = plain.depthFailOp;
    if (plain.passOp !== undefined) struct.passOp = plain.passOp;
    return struct;
  }
  set(plain: ToStencilFaceState) {
    if (plain === undefined) return;
    if (plain.compare !== undefined) this.compare = plain.compare;
    if (plain.failOp !== undefined) this.failOp = plain.failOp;
    if (plain.depthFailOp !== undefined) this.depthFailOp = plain.depthFailOp;
    if (plain.passOp !== undefined) this.passOp = plain.passOp;
  }
}

export type ToStorageTextureBindingLayout = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  access?: StorageTextureAccess;
  format?: TextureFormat;
  viewDimension?: TextureViewDimension;
};

export class StorageTextureBindingLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get access(): StorageTextureAccess {
    return this.dataview.getUint32(8, U.LE) as StorageTextureAccess;
  }

  set access(value: StorageTextureAccess) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(12, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get viewDimension(): TextureViewDimension {
    return this.dataview.getUint32(16, U.LE) as TextureViewDimension;
  }

  set viewDimension(value: TextureViewDimension) {
    this.dataview.setUint32(16, value, U.LE);
  }

  static from(plain: ToStorageTextureBindingLayout) {
    const struct = new StorageTextureBindingLayout();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.access !== undefined) struct.access = plain.access;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.viewDimension !== undefined) {
      struct.viewDimension = plain.viewDimension;
    }
    return struct;
  }
  set(plain: ToStorageTextureBindingLayout) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.access !== undefined) this.access = plain.access;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.viewDimension !== undefined) {
      this.viewDimension = plain.viewDimension;
    }
  }
}

export type ToSurfaceDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
};

export class SurfaceDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptor) {
    const struct = new SurfaceDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    return struct;
  }
  set(plain: ToSurfaceDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
  }
}

export type ToSurfaceDescriptorFromAndroidNativeWindow = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  window?: Deno.PointerValue;
};

export class SurfaceDescriptorFromAndroidNativeWindow extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.SurfaceDescriptorFromAndroidNativeWindow;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get window(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set window(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptorFromAndroidNativeWindow) {
    const struct = new SurfaceDescriptorFromAndroidNativeWindow();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.window !== undefined) struct.window = plain.window;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromAndroidNativeWindow) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.window !== undefined) this.window = plain.window;
  }
}

export type ToSurfaceDescriptorFromCanvasHTMLSelector = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  selector?: Deno.PointerValue;
};

export class SurfaceDescriptorFromCanvasHTMLSelector extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.SurfaceDescriptorFromCanvasHTMLSelector;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get selector(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set selector(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptorFromCanvasHTMLSelector) {
    const struct = new SurfaceDescriptorFromCanvasHTMLSelector();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.selector !== undefined) struct.selector = plain.selector;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromCanvasHTMLSelector) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.selector !== undefined) this.selector = plain.selector;
  }
}

export type ToSurfaceDescriptorFromMetalLayer = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  layer?: Deno.PointerValue;
};

export class SurfaceDescriptorFromMetalLayer extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.SurfaceDescriptorFromMetalLayer;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get layer(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set layer(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptorFromMetalLayer) {
    const struct = new SurfaceDescriptorFromMetalLayer();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.layer !== undefined) struct.layer = plain.layer;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromMetalLayer) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.layer !== undefined) this.layer = plain.layer;
  }
}

export type ToSurfaceDescriptorFromWaylandSurface = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  display?: Deno.PointerValue;
  surface?: Deno.PointerValue;
};

export class SurfaceDescriptorFromWaylandSurface extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.SurfaceDescriptorFromWaylandSurface;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get display(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set display(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get surface(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set surface(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptorFromWaylandSurface) {
    const struct = new SurfaceDescriptorFromWaylandSurface();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.display !== undefined) struct.display = plain.display;
    if (plain.surface !== undefined) struct.surface = plain.surface;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromWaylandSurface) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.display !== undefined) this.display = plain.display;
    if (plain.surface !== undefined) this.surface = plain.surface;
  }
}

export type ToSurfaceDescriptorFromWindowsHWND = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  hinstance?: Deno.PointerValue;
  hwnd?: Deno.PointerValue;
};

export class SurfaceDescriptorFromWindowsHWND extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.SurfaceDescriptorFromWindowsHWND;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get hinstance(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set hinstance(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get hwnd(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set hwnd(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceDescriptorFromWindowsHWND) {
    const struct = new SurfaceDescriptorFromWindowsHWND();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.hinstance !== undefined) struct.hinstance = plain.hinstance;
    if (plain.hwnd !== undefined) struct.hwnd = plain.hwnd;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromWindowsHWND) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.hinstance !== undefined) this.hinstance = plain.hinstance;
    if (plain.hwnd !== undefined) this.hwnd = plain.hwnd;
  }
}

export type ToSurfaceDescriptorFromXcbWindow = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  connection?: Deno.PointerValue;
  window?: number;
};

export class SurfaceDescriptorFromXcbWindow extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.SurfaceDescriptorFromXcbWindow;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get connection(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set connection(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get window(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set window(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  static from(plain: ToSurfaceDescriptorFromXcbWindow) {
    const struct = new SurfaceDescriptorFromXcbWindow();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.connection !== undefined) struct.connection = plain.connection;
    if (plain.window !== undefined) struct.window = plain.window;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromXcbWindow) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.connection !== undefined) this.connection = plain.connection;
    if (plain.window !== undefined) this.window = plain.window;
  }
}

export type ToSurfaceDescriptorFromXlibWindow = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  display?: Deno.PointerValue;
  window?: number;
};

export class SurfaceDescriptorFromXlibWindow extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.SurfaceDescriptorFromXlibWindow;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get display(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set display(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get window(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set window(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  static from(plain: ToSurfaceDescriptorFromXlibWindow) {
    const struct = new SurfaceDescriptorFromXlibWindow();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.display !== undefined) struct.display = plain.display;
    if (plain.window !== undefined) struct.window = plain.window;
    return struct;
  }
  set(plain: ToSurfaceDescriptorFromXlibWindow) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.display !== undefined) this.display = plain.display;
    if (plain.window !== undefined) this.window = plain.window;
  }
}

export type ToSwapChainDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  usage?: number;
  format?: TextureFormat;
  width?: number;
  height?: number;
  presentMode?: PresentMode;
};

export class SwapChainDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get usage(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set usage(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(20, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get width(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set width(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  get height(): number {
    return this.dataview.getUint32(28, U.LE);
  }

  set height(value: number) {
    this.dataview.setUint32(28, value, U.LE);
  }

  get presentMode(): PresentMode {
    return this.dataview.getUint32(32, U.LE) as PresentMode;
  }

  set presentMode(value: PresentMode) {
    this.dataview.setUint32(32, value, U.LE);
  }

  static from(plain: ToSwapChainDescriptor) {
    const struct = new SwapChainDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.usage !== undefined) struct.usage = plain.usage;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.width !== undefined) struct.width = plain.width;
    if (plain.height !== undefined) struct.height = plain.height;
    if (plain.presentMode !== undefined) struct.presentMode = plain.presentMode;
    return struct;
  }
  set(plain: ToSwapChainDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.usage !== undefined) this.usage = plain.usage;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.width !== undefined) this.width = plain.width;
    if (plain.height !== undefined) this.height = plain.height;
    if (plain.presentMode !== undefined) this.presentMode = plain.presentMode;
  }
}

export type ToTextureBindingLayout = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  sampleType?: TextureSampleType;
  viewDimension?: TextureViewDimension;
  multisampled?: boolean | number | bigint;
};

export class TextureBindingLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get sampleType(): TextureSampleType {
    return this.dataview.getUint32(8, U.LE) as TextureSampleType;
  }

  set sampleType(value: TextureSampleType) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get viewDimension(): TextureViewDimension {
    return this.dataview.getUint32(12, U.LE) as TextureViewDimension;
  }

  set viewDimension(value: TextureViewDimension) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get multisampled(): boolean {
    return this.dataview.getUint8(16) == 1;
  }

  set multisampled(value: boolean | number | bigint) {
    this.dataview.setUint8(16, value ? 1 : 0);
  }

  static from(plain: ToTextureBindingLayout) {
    const struct = new TextureBindingLayout();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.sampleType !== undefined) struct.sampleType = plain.sampleType;
    if (plain.viewDimension !== undefined) {
      struct.viewDimension = plain.viewDimension;
    }
    if (plain.multisampled !== undefined) {
      struct.multisampled = plain.multisampled;
    }
    return struct;
  }
  set(plain: ToTextureBindingLayout) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.sampleType !== undefined) this.sampleType = plain.sampleType;
    if (plain.viewDimension !== undefined) {
      this.viewDimension = plain.viewDimension;
    }
    if (plain.multisampled !== undefined) {
      this.multisampled = plain.multisampled;
    }
  }
}

export type ToTextureDataLayout = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  offset?: bigint | number;
  bytesPerRow?: number;
  rowsPerImage?: number;
};

export class TextureDataLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get offset(): bigint {
    return this.dataview.getBigUint64(8, U.LE);
  }

  set offset(value: bigint | number) {
    this.dataview.setBigUint64(8, BigInt(value), U.LE);
  }

  get bytesPerRow(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set bytesPerRow(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get rowsPerImage(): number {
    return this.dataview.getUint32(20, U.LE);
  }

  set rowsPerImage(value: number) {
    this.dataview.setUint32(20, value, U.LE);
  }

  static from(plain: ToTextureDataLayout) {
    const struct = new TextureDataLayout();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.offset !== undefined) struct.offset = plain.offset;
    if (plain.bytesPerRow !== undefined) struct.bytesPerRow = plain.bytesPerRow;
    if (plain.rowsPerImage !== undefined) {
      struct.rowsPerImage = plain.rowsPerImage;
    }
    return struct;
  }
  set(plain: ToTextureDataLayout) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.offset !== undefined) this.offset = plain.offset;
    if (plain.bytesPerRow !== undefined) this.bytesPerRow = plain.bytesPerRow;
    if (plain.rowsPerImage !== undefined) {
      this.rowsPerImage = plain.rowsPerImage;
    }
  }
}

export type ToTextureViewDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  format?: TextureFormat;
  dimension?: TextureViewDimension;
  baseMipLevel?: number;
  mipLevelCount?: number;
  baseArrayLayer?: number;
  arrayLayerCount?: number;
  aspect?: TextureAspect;
};

export class TextureViewDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(48));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(48),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(16, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get dimension(): TextureViewDimension {
    return this.dataview.getUint32(20, U.LE) as TextureViewDimension;
  }

  set dimension(value: TextureViewDimension) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get baseMipLevel(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set baseMipLevel(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  get mipLevelCount(): number {
    return this.dataview.getUint32(28, U.LE);
  }

  set mipLevelCount(value: number) {
    this.dataview.setUint32(28, value, U.LE);
  }

  get baseArrayLayer(): number {
    return this.dataview.getUint32(32, U.LE);
  }

  set baseArrayLayer(value: number) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get arrayLayerCount(): number {
    return this.dataview.getUint32(36, U.LE);
  }

  set arrayLayerCount(value: number) {
    this.dataview.setUint32(36, value, U.LE);
  }

  get aspect(): TextureAspect {
    return this.dataview.getUint32(40, U.LE) as TextureAspect;
  }

  set aspect(value: TextureAspect) {
    this.dataview.setUint32(40, value, U.LE);
  }

  static from(plain: ToTextureViewDescriptor) {
    const struct = new TextureViewDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.dimension !== undefined) struct.dimension = plain.dimension;
    if (plain.baseMipLevel !== undefined) {
      struct.baseMipLevel = plain.baseMipLevel;
    }
    if (plain.mipLevelCount !== undefined) {
      struct.mipLevelCount = plain.mipLevelCount;
    }
    if (plain.baseArrayLayer !== undefined) {
      struct.baseArrayLayer = plain.baseArrayLayer;
    }
    if (plain.arrayLayerCount !== undefined) {
      struct.arrayLayerCount = plain.arrayLayerCount;
    }
    if (plain.aspect !== undefined) struct.aspect = plain.aspect;
    return struct;
  }
  set(plain: ToTextureViewDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.dimension !== undefined) this.dimension = plain.dimension;
    if (plain.baseMipLevel !== undefined) {
      this.baseMipLevel = plain.baseMipLevel;
    }
    if (plain.mipLevelCount !== undefined) {
      this.mipLevelCount = plain.mipLevelCount;
    }
    if (plain.baseArrayLayer !== undefined) {
      this.baseArrayLayer = plain.baseArrayLayer;
    }
    if (plain.arrayLayerCount !== undefined) {
      this.arrayLayerCount = plain.arrayLayerCount;
    }
    if (plain.aspect !== undefined) this.aspect = plain.aspect;
  }
}

export type ToVertexAttribute = undefined | {
  format?: VertexFormat;
  offset?: bigint | number;
  shaderLocation?: number;
};

export class VertexAttribute extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get format(): VertexFormat {
    return this.dataview.getUint32(0, U.LE) as VertexFormat;
  }

  set format(value: VertexFormat) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get offset(): bigint {
    return this.dataview.getBigUint64(8, U.LE);
  }

  set offset(value: bigint | number) {
    this.dataview.setBigUint64(8, BigInt(value), U.LE);
  }

  get shaderLocation(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set shaderLocation(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  static from(plain: ToVertexAttribute) {
    const struct = new VertexAttribute();
    if (plain === undefined) return struct;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.offset !== undefined) struct.offset = plain.offset;
    if (plain.shaderLocation !== undefined) {
      struct.shaderLocation = plain.shaderLocation;
    }
    return struct;
  }
  set(plain: ToVertexAttribute) {
    if (plain === undefined) return;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.offset !== undefined) this.offset = plain.offset;
    if (plain.shaderLocation !== undefined) {
      this.shaderLocation = plain.shaderLocation;
    }
  }
}

export type ToBindGroupDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  layout?: Deno.PointerValue | BindGroupLayout;
  entryCount?: bigint | number;
  entries?: Deno.PointerValue | BindGroupEntry | ToBindGroupEntry;
};

export class BindGroupDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get layout(): BindGroupLayout {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return new BindGroupLayout(ptr);
  }

  set layout(value: Deno.PointerValue | BindGroupLayout) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryCount(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set entryCount(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get entries(): BindGroupEntry | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new BindGroupEntry(ptr);
  }

  set entries(value: Deno.PointerValue | BindGroupEntry | ToBindGroupEntry) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : BindGroupEntry.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToBindGroupDescriptor) {
    const struct = new BindGroupDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.layout !== undefined) struct.layout = plain.layout;
    if (plain.entryCount !== undefined) struct.entryCount = plain.entryCount;
    if (plain.entries !== undefined) struct.entries = plain.entries;
    return struct;
  }
  set(plain: ToBindGroupDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.layout !== undefined) this.layout = plain.layout;
    if (plain.entryCount !== undefined) this.entryCount = plain.entryCount;
    if (plain.entries !== undefined) this.entries = plain.entries;
  }
}

export type ToBindGroupLayoutEntry = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  binding?: number;
  visibility?: number;
  buffer?: BufferBindingLayout | ToBufferBindingLayout;
  sampler?: SamplerBindingLayout | ToSamplerBindingLayout;
  texture?: TextureBindingLayout | ToTextureBindingLayout;
  storageTexture?: StorageTextureBindingLayout | ToStorageTextureBindingLayout;
};

export class BindGroupLayoutEntry extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(104));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(104),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get binding(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set binding(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get visibility(): number {
    return this.dataview.getUint32(12, U.LE);
  }

  set visibility(value: number) {
    this.dataview.setUint32(12, value, U.LE);
  }

  get buffer(): BufferBindingLayout {
    return new BufferBindingLayout(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 16, 24),
    );
  }

  set buffer(value: BufferBindingLayout | ToBufferBindingLayout) {
    if (value instanceof BufferBindingLayout) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.buffer.set(value);
    }
  }

  get sampler(): SamplerBindingLayout {
    return new SamplerBindingLayout(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 40, 16),
    );
  }

  set sampler(value: SamplerBindingLayout | ToSamplerBindingLayout) {
    if (value instanceof SamplerBindingLayout) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.sampler.set(value);
    }
  }

  get texture(): TextureBindingLayout {
    return new TextureBindingLayout(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 56, 24),
    );
  }

  set texture(value: TextureBindingLayout | ToTextureBindingLayout) {
    if (value instanceof TextureBindingLayout) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.texture.set(value);
    }
  }

  get storageTexture(): StorageTextureBindingLayout {
    return new StorageTextureBindingLayout(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 80, 24),
    );
  }

  set storageTexture(
    value: StorageTextureBindingLayout | ToStorageTextureBindingLayout,
  ) {
    if (value instanceof StorageTextureBindingLayout) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.storageTexture.set(value);
    }
  }

  static from(plain: ToBindGroupLayoutEntry) {
    const struct = new BindGroupLayoutEntry();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.binding !== undefined) struct.binding = plain.binding;
    if (plain.visibility !== undefined) struct.visibility = plain.visibility;
    if (plain.buffer !== undefined) struct.buffer = plain.buffer;
    if (plain.sampler !== undefined) struct.sampler = plain.sampler;
    if (plain.texture !== undefined) struct.texture = plain.texture;
    if (plain.storageTexture !== undefined) {
      struct.storageTexture = plain.storageTexture;
    }
    return struct;
  }
  set(plain: ToBindGroupLayoutEntry) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.binding !== undefined) this.binding = plain.binding;
    if (plain.visibility !== undefined) this.visibility = plain.visibility;
    if (plain.buffer !== undefined) this.buffer = plain.buffer;
    if (plain.sampler !== undefined) this.sampler = plain.sampler;
    if (plain.texture !== undefined) this.texture = plain.texture;
    if (plain.storageTexture !== undefined) {
      this.storageTexture = plain.storageTexture;
    }
  }
}

export type ToBlendState = undefined | {
  color?: BlendComponent | ToBlendComponent;
  alpha?: BlendComponent | ToBlendComponent;
};

export class BlendState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get color(): BlendComponent {
    return new BlendComponent(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 12),
    );
  }

  set color(value: BlendComponent | ToBlendComponent) {
    if (value instanceof BlendComponent) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 12).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.color.set(value);
    }
  }

  get alpha(): BlendComponent {
    return new BlendComponent(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 12, 12),
    );
  }

  set alpha(value: BlendComponent | ToBlendComponent) {
    if (value instanceof BlendComponent) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 12).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.alpha.set(value);
    }
  }

  static from(plain: ToBlendState) {
    const struct = new BlendState();
    if (plain === undefined) return struct;
    if (plain.color !== undefined) struct.color = plain.color;
    if (plain.alpha !== undefined) struct.alpha = plain.alpha;
    return struct;
  }
  set(plain: ToBlendState) {
    if (plain === undefined) return;
    if (plain.color !== undefined) this.color = plain.color;
    if (plain.alpha !== undefined) this.alpha = plain.alpha;
  }
}

export type ToCompilationInfo = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  messageCount?: bigint | number;
  messages?: Deno.PointerValue | CompilationMessage | ToCompilationMessage;
};

export class CompilationInfo extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get messageCount(): bigint {
    return this.dataview.getBigUint64(8, U.LE);
  }

  set messageCount(value: bigint | number) {
    this.dataview.setBigUint64(8, BigInt(value), U.LE);
  }

  get messages(): CompilationMessage | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    if (ptr == null) return null;
    else return new CompilationMessage(ptr);
  }

  set messages(
    value: Deno.PointerValue | CompilationMessage | ToCompilationMessage,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : CompilationMessage.from(value).pointer;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToCompilationInfo) {
    const struct = new CompilationInfo();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.messageCount !== undefined) {
      struct.messageCount = plain.messageCount;
    }
    if (plain.messages !== undefined) struct.messages = plain.messages;
    return struct;
  }
  set(plain: ToCompilationInfo) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.messageCount !== undefined) {
      this.messageCount = plain.messageCount;
    }
    if (plain.messages !== undefined) this.messages = plain.messages;
  }
}

export type ToComputePassDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  timestampWriteCount?: bigint | number;
  timestampWrites?:
    | Deno.PointerValue
    | ComputePassTimestampWrite
    | ToComputePassTimestampWrite;
};

export class ComputePassDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get timestampWriteCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set timestampWriteCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get timestampWrites(): ComputePassTimestampWrite | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new ComputePassTimestampWrite(ptr);
  }

  set timestampWrites(
    value:
      | Deno.PointerValue
      | ComputePassTimestampWrite
      | ToComputePassTimestampWrite,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ComputePassTimestampWrite.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToComputePassDescriptor) {
    const struct = new ComputePassDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.timestampWriteCount !== undefined) {
      struct.timestampWriteCount = plain.timestampWriteCount;
    }
    if (plain.timestampWrites !== undefined) {
      struct.timestampWrites = plain.timestampWrites;
    }
    return struct;
  }
  set(plain: ToComputePassDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.timestampWriteCount !== undefined) {
      this.timestampWriteCount = plain.timestampWriteCount;
    }
    if (plain.timestampWrites !== undefined) {
      this.timestampWrites = plain.timestampWrites;
    }
  }
}

export type ToDepthStencilState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  format?: TextureFormat;
  depthWriteEnabled?: boolean | number | bigint;
  depthCompare?: CompareFunction;
  stencilFront?: StencilFaceState | ToStencilFaceState;
  stencilBack?: StencilFaceState | ToStencilFaceState;
  stencilReadMask?: number;
  stencilWriteMask?: number;
  depthBias?: number;
  depthBiasSlopeScale?: number;
  depthBiasClamp?: number;
};

export class DepthStencilState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(72));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(72),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(8, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get depthWriteEnabled(): boolean {
    return this.dataview.getUint8(12) == 1;
  }

  set depthWriteEnabled(value: boolean | number | bigint) {
    this.dataview.setUint8(12, value ? 1 : 0);
  }

  get depthCompare(): CompareFunction {
    return this.dataview.getUint32(16, U.LE) as CompareFunction;
  }

  set depthCompare(value: CompareFunction) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get stencilFront(): StencilFaceState {
    return new StencilFaceState(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 20, 16),
    );
  }

  set stencilFront(value: StencilFaceState | ToStencilFaceState) {
    if (value instanceof StencilFaceState) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.stencilFront.set(value);
    }
  }

  get stencilBack(): StencilFaceState {
    return new StencilFaceState(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 36, 16),
    );
  }

  set stencilBack(value: StencilFaceState | ToStencilFaceState) {
    if (value instanceof StencilFaceState) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.stencilBack.set(value);
    }
  }

  get stencilReadMask(): number {
    return this.dataview.getUint32(52, U.LE);
  }

  set stencilReadMask(value: number) {
    this.dataview.setUint32(52, value, U.LE);
  }

  get stencilWriteMask(): number {
    return this.dataview.getUint32(56, U.LE);
  }

  set stencilWriteMask(value: number) {
    this.dataview.setUint32(56, value, U.LE);
  }

  get depthBias(): number {
    return this.dataview.getInt32(60, U.LE);
  }

  set depthBias(value: number) {
    this.dataview.setInt32(60, value, U.LE);
  }

  get depthBiasSlopeScale(): number {
    return this.dataview.getFloat32(64, U.LE);
  }

  set depthBiasSlopeScale(value: number) {
    this.dataview.setFloat32(64, value, U.LE);
  }

  get depthBiasClamp(): number {
    return this.dataview.getFloat32(68, U.LE);
  }

  set depthBiasClamp(value: number) {
    this.dataview.setFloat32(68, value, U.LE);
  }

  static from(plain: ToDepthStencilState) {
    const struct = new DepthStencilState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.depthWriteEnabled !== undefined) {
      struct.depthWriteEnabled = plain.depthWriteEnabled;
    }
    if (plain.depthCompare !== undefined) {
      struct.depthCompare = plain.depthCompare;
    }
    if (plain.stencilFront !== undefined) {
      struct.stencilFront = plain.stencilFront;
    }
    if (plain.stencilBack !== undefined) struct.stencilBack = plain.stencilBack;
    if (plain.stencilReadMask !== undefined) {
      struct.stencilReadMask = plain.stencilReadMask;
    }
    if (plain.stencilWriteMask !== undefined) {
      struct.stencilWriteMask = plain.stencilWriteMask;
    }
    if (plain.depthBias !== undefined) struct.depthBias = plain.depthBias;
    if (plain.depthBiasSlopeScale !== undefined) {
      struct.depthBiasSlopeScale = plain.depthBiasSlopeScale;
    }
    if (plain.depthBiasClamp !== undefined) {
      struct.depthBiasClamp = plain.depthBiasClamp;
    }
    return struct;
  }
  set(plain: ToDepthStencilState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.depthWriteEnabled !== undefined) {
      this.depthWriteEnabled = plain.depthWriteEnabled;
    }
    if (plain.depthCompare !== undefined) {
      this.depthCompare = plain.depthCompare;
    }
    if (plain.stencilFront !== undefined) {
      this.stencilFront = plain.stencilFront;
    }
    if (plain.stencilBack !== undefined) this.stencilBack = plain.stencilBack;
    if (plain.stencilReadMask !== undefined) {
      this.stencilReadMask = plain.stencilReadMask;
    }
    if (plain.stencilWriteMask !== undefined) {
      this.stencilWriteMask = plain.stencilWriteMask;
    }
    if (plain.depthBias !== undefined) this.depthBias = plain.depthBias;
    if (plain.depthBiasSlopeScale !== undefined) {
      this.depthBiasSlopeScale = plain.depthBiasSlopeScale;
    }
    if (plain.depthBiasClamp !== undefined) {
      this.depthBiasClamp = plain.depthBiasClamp;
    }
  }
}

export type ToImageCopyBuffer = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  layout?: TextureDataLayout | ToTextureDataLayout;
  buffer?: Deno.PointerValue | Buffer;
};

export class ImageCopyBuffer extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get layout(): TextureDataLayout {
    return new TextureDataLayout(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 8, 24),
    );
  }

  set layout(value: TextureDataLayout | ToTextureDataLayout) {
    if (value instanceof TextureDataLayout) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.layout.set(value);
    }
  }

  get buffer(): Buffer {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    return new Buffer(ptr);
  }

  set buffer(value: Deno.PointerValue | Buffer) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToImageCopyBuffer) {
    const struct = new ImageCopyBuffer();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.layout !== undefined) struct.layout = plain.layout;
    if (plain.buffer !== undefined) struct.buffer = plain.buffer;
    return struct;
  }
  set(plain: ToImageCopyBuffer) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.layout !== undefined) this.layout = plain.layout;
    if (plain.buffer !== undefined) this.buffer = plain.buffer;
  }
}

export type ToImageCopyTexture = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  texture?: Deno.PointerValue | Texture;
  mipLevel?: number;
  origin?: Origin3D | ToOrigin3D;
  aspect?: TextureAspect;
};

export class ImageCopyTexture extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get texture(): Texture {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new Texture(ptr);
  }

  set texture(value: Deno.PointerValue | Texture) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get mipLevel(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set mipLevel(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get origin(): Origin3D {
    return new Origin3D(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 20, 12),
    );
  }

  set origin(value: Origin3D | ToOrigin3D) {
    if (value instanceof Origin3D) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 12).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.origin.set(value);
    }
  }

  get aspect(): TextureAspect {
    return this.dataview.getUint32(32, U.LE) as TextureAspect;
  }

  set aspect(value: TextureAspect) {
    this.dataview.setUint32(32, value, U.LE);
  }

  static from(plain: ToImageCopyTexture) {
    const struct = new ImageCopyTexture();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.texture !== undefined) struct.texture = plain.texture;
    if (plain.mipLevel !== undefined) struct.mipLevel = plain.mipLevel;
    if (plain.origin !== undefined) struct.origin = plain.origin;
    if (plain.aspect !== undefined) struct.aspect = plain.aspect;
    return struct;
  }
  set(plain: ToImageCopyTexture) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.texture !== undefined) this.texture = plain.texture;
    if (plain.mipLevel !== undefined) this.mipLevel = plain.mipLevel;
    if (plain.origin !== undefined) this.origin = plain.origin;
    if (plain.aspect !== undefined) this.aspect = plain.aspect;
  }
}

export type ToProgrammableStageDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  module?: Deno.PointerValue | ShaderModule;
  entryPoint?: Deno.PointerValue;
  constantCount?: bigint | number;
  constants?: Deno.PointerValue | ConstantEntry | ToConstantEntry;
};

export class ProgrammableStageDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get module(): ShaderModule {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new ShaderModule(ptr);
  }

  set module(value: Deno.PointerValue | ShaderModule) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryPoint(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set entryPoint(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get constantCount(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set constantCount(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get constants(): ConstantEntry | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new ConstantEntry(ptr);
  }

  set constants(value: Deno.PointerValue | ConstantEntry | ToConstantEntry) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ConstantEntry.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToProgrammableStageDescriptor) {
    const struct = new ProgrammableStageDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) struct.module = plain.module;
    if (plain.entryPoint !== undefined) struct.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      struct.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) struct.constants = plain.constants;
    return struct;
  }
  set(plain: ToProgrammableStageDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) this.module = plain.module;
    if (plain.entryPoint !== undefined) this.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      this.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) this.constants = plain.constants;
  }
}

export type ToRenderPassColorAttachment = undefined | {
  view?: Deno.PointerValue | TextureView;
  resolveTarget?: Deno.PointerValue | TextureView;
  loadOp?: LoadOp;
  storeOp?: StoreOp;
  clearValue?: Color | ToColor;
};

export class RenderPassColorAttachment extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(56));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(56),
        );
      }
    }
  }

  get view(): TextureView {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return new TextureView(ptr);
  }

  set view(value: Deno.PointerValue | TextureView) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get resolveTarget(): TextureView {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new TextureView(ptr);
  }

  set resolveTarget(value: Deno.PointerValue | TextureView) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get loadOp(): LoadOp {
    return this.dataview.getUint32(16, U.LE) as LoadOp;
  }

  set loadOp(value: LoadOp) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get storeOp(): StoreOp {
    return this.dataview.getUint32(20, U.LE) as StoreOp;
  }

  set storeOp(value: StoreOp) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get clearValue(): Color {
    return new Color(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 24, 32),
    );
  }

  set clearValue(value: Color | ToColor) {
    if (value instanceof Color) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.clearValue.set(value);
    }
  }

  static from(plain: ToRenderPassColorAttachment) {
    const struct = new RenderPassColorAttachment();
    if (plain === undefined) return struct;
    if (plain.view !== undefined) struct.view = plain.view;
    if (plain.resolveTarget !== undefined) {
      struct.resolveTarget = plain.resolveTarget;
    }
    if (plain.loadOp !== undefined) struct.loadOp = plain.loadOp;
    if (plain.storeOp !== undefined) struct.storeOp = plain.storeOp;
    if (plain.clearValue !== undefined) struct.clearValue = plain.clearValue;
    return struct;
  }
  set(plain: ToRenderPassColorAttachment) {
    if (plain === undefined) return;
    if (plain.view !== undefined) this.view = plain.view;
    if (plain.resolveTarget !== undefined) {
      this.resolveTarget = plain.resolveTarget;
    }
    if (plain.loadOp !== undefined) this.loadOp = plain.loadOp;
    if (plain.storeOp !== undefined) this.storeOp = plain.storeOp;
    if (plain.clearValue !== undefined) this.clearValue = plain.clearValue;
  }
}

export type ToRequiredLimits = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  limits?: Limits | ToLimits;
};

export class RequiredLimits extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(152));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(152),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get limits(): Limits {
    return new Limits(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 8, 144),
    );
  }

  set limits(value: Limits | ToLimits) {
    if (value instanceof Limits) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 144).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.limits.set(value);
    }
  }

  static from(plain: ToRequiredLimits) {
    const struct = new RequiredLimits();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.limits !== undefined) struct.limits = plain.limits;
    return struct;
  }
  set(plain: ToRequiredLimits) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.limits !== undefined) this.limits = plain.limits;
  }
}

export type ToShaderModuleDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  hintCount?: bigint | number;
  hints?:
    | Deno.PointerValue
    | ShaderModuleCompilationHint
    | ToShaderModuleCompilationHint;
};

export class ShaderModuleDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get hintCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set hintCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get hints(): ShaderModuleCompilationHint | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new ShaderModuleCompilationHint(ptr);
  }

  set hints(
    value:
      | Deno.PointerValue
      | ShaderModuleCompilationHint
      | ToShaderModuleCompilationHint,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ShaderModuleCompilationHint.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderModuleDescriptor) {
    const struct = new ShaderModuleDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.hintCount !== undefined) struct.hintCount = plain.hintCount;
    if (plain.hints !== undefined) struct.hints = plain.hints;
    return struct;
  }
  set(plain: ToShaderModuleDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.hintCount !== undefined) this.hintCount = plain.hintCount;
    if (plain.hints !== undefined) this.hints = plain.hints;
  }
}

export type ToSupportedLimits = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStructOut | ToChainedStructOut;
    [key: string]: any;
  };
  limits?: Limits | ToLimits;
};

export class SupportedLimits extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(152));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(152),
        );
      }
    }
  }

  get nextInChain(): ChainedStructOut | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStructOut(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStructOut | ToChainedStructOut;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get limits(): Limits {
    return new Limits(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 8, 144),
    );
  }

  set limits(value: Limits | ToLimits) {
    if (value instanceof Limits) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 144).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.limits.set(value);
    }
  }

  static from(plain: ToSupportedLimits) {
    const struct = new SupportedLimits();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.limits !== undefined) struct.limits = plain.limits;
    return struct;
  }
  set(plain: ToSupportedLimits) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.limits !== undefined) this.limits = plain.limits;
  }
}

export type ToTextureDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  usage?: number;
  dimension?: TextureDimension;
  size?: Extent3D | ToExtent3D;
  format?: TextureFormat;
  mipLevelCount?: number;
  sampleCount?: number;
  viewFormatCount?: bigint | number;
  viewFormats?: Deno.PointerValue;
};

export class TextureDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(64));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(64),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get usage(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set usage(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get dimension(): TextureDimension {
    return this.dataview.getUint32(20, U.LE) as TextureDimension;
  }

  set dimension(value: TextureDimension) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get size(): Extent3D {
    return new Extent3D(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 24, 12),
    );
  }

  set size(value: Extent3D | ToExtent3D) {
    if (value instanceof Extent3D) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 12).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.size.set(value);
    }
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(36, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(36, value, U.LE);
  }

  get mipLevelCount(): number {
    return this.dataview.getUint32(40, U.LE);
  }

  set mipLevelCount(value: number) {
    this.dataview.setUint32(40, value, U.LE);
  }

  get sampleCount(): number {
    return this.dataview.getUint32(44, U.LE);
  }

  set sampleCount(value: number) {
    this.dataview.setUint32(44, value, U.LE);
  }

  get viewFormatCount(): bigint {
    return this.dataview.getBigUint64(48, U.LE);
  }

  set viewFormatCount(value: bigint | number) {
    this.dataview.setBigUint64(48, BigInt(value), U.LE);
  }

  get viewFormats(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(56, U.LE));
    return ptr;
  }

  set viewFormats(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      56,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToTextureDescriptor) {
    const struct = new TextureDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.usage !== undefined) struct.usage = plain.usage;
    if (plain.dimension !== undefined) struct.dimension = plain.dimension;
    if (plain.size !== undefined) struct.size = plain.size;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.mipLevelCount !== undefined) {
      struct.mipLevelCount = plain.mipLevelCount;
    }
    if (plain.sampleCount !== undefined) struct.sampleCount = plain.sampleCount;
    if (plain.viewFormatCount !== undefined) {
      struct.viewFormatCount = plain.viewFormatCount;
    }
    if (plain.viewFormats !== undefined) struct.viewFormats = plain.viewFormats;
    return struct;
  }
  set(plain: ToTextureDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.usage !== undefined) this.usage = plain.usage;
    if (plain.dimension !== undefined) this.dimension = plain.dimension;
    if (plain.size !== undefined) this.size = plain.size;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.mipLevelCount !== undefined) {
      this.mipLevelCount = plain.mipLevelCount;
    }
    if (plain.sampleCount !== undefined) this.sampleCount = plain.sampleCount;
    if (plain.viewFormatCount !== undefined) {
      this.viewFormatCount = plain.viewFormatCount;
    }
    if (plain.viewFormats !== undefined) this.viewFormats = plain.viewFormats;
  }
}

export type ToVertexBufferLayout = undefined | {
  arrayStride?: bigint | number;
  stepMode?: VertexStepMode;
  attributeCount?: bigint | number;
  attributes?: Deno.PointerValue | VertexAttribute | ToVertexAttribute;
};

export class VertexBufferLayout extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get arrayStride(): bigint {
    return this.dataview.getBigUint64(0, U.LE);
  }

  set arrayStride(value: bigint | number) {
    this.dataview.setBigUint64(0, BigInt(value), U.LE);
  }

  get stepMode(): VertexStepMode {
    return this.dataview.getUint32(8, U.LE) as VertexStepMode;
  }

  set stepMode(value: VertexStepMode) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get attributeCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set attributeCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get attributes(): VertexAttribute | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new VertexAttribute(ptr);
  }

  set attributes(
    value: Deno.PointerValue | VertexAttribute | ToVertexAttribute,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : VertexAttribute.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToVertexBufferLayout) {
    const struct = new VertexBufferLayout();
    if (plain === undefined) return struct;
    if (plain.arrayStride !== undefined) struct.arrayStride = plain.arrayStride;
    if (plain.stepMode !== undefined) struct.stepMode = plain.stepMode;
    if (plain.attributeCount !== undefined) {
      struct.attributeCount = plain.attributeCount;
    }
    if (plain.attributes !== undefined) struct.attributes = plain.attributes;
    return struct;
  }
  set(plain: ToVertexBufferLayout) {
    if (plain === undefined) return;
    if (plain.arrayStride !== undefined) this.arrayStride = plain.arrayStride;
    if (plain.stepMode !== undefined) this.stepMode = plain.stepMode;
    if (plain.attributeCount !== undefined) {
      this.attributeCount = plain.attributeCount;
    }
    if (plain.attributes !== undefined) this.attributes = plain.attributes;
  }
}

export type ToBindGroupLayoutDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  entryCount?: bigint | number;
  entries?: Deno.PointerValue | BindGroupLayoutEntry | ToBindGroupLayoutEntry;
};

export class BindGroupLayoutDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set entryCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get entries(): BindGroupLayoutEntry | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new BindGroupLayoutEntry(ptr);
  }

  set entries(
    value: Deno.PointerValue | BindGroupLayoutEntry | ToBindGroupLayoutEntry,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : BindGroupLayoutEntry.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToBindGroupLayoutDescriptor) {
    const struct = new BindGroupLayoutDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.entryCount !== undefined) struct.entryCount = plain.entryCount;
    if (plain.entries !== undefined) struct.entries = plain.entries;
    return struct;
  }
  set(plain: ToBindGroupLayoutDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.entryCount !== undefined) this.entryCount = plain.entryCount;
    if (plain.entries !== undefined) this.entries = plain.entries;
  }
}

export type ToColorTargetState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  format?: TextureFormat;
  blend?: Deno.PointerValue | BlendState | ToBlendState;
  writeMask?: number;
};

export class ColorTargetState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get format(): TextureFormat {
    return this.dataview.getUint32(8, U.LE) as TextureFormat;
  }

  set format(value: TextureFormat) {
    this.dataview.setUint32(8, value, U.LE);
  }

  get blend(): BlendState | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    if (ptr == null) return null;
    else return new BlendState(ptr);
  }

  set blend(value: Deno.PointerValue | BlendState | ToBlendState) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : BlendState.from(value).pointer;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get writeMask(): number {
    return this.dataview.getUint32(24, U.LE);
  }

  set writeMask(value: number) {
    this.dataview.setUint32(24, value, U.LE);
  }

  static from(plain: ToColorTargetState) {
    const struct = new ColorTargetState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.format !== undefined) struct.format = plain.format;
    if (plain.blend !== undefined) struct.blend = plain.blend;
    if (plain.writeMask !== undefined) struct.writeMask = plain.writeMask;
    return struct;
  }
  set(plain: ToColorTargetState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.format !== undefined) this.format = plain.format;
    if (plain.blend !== undefined) this.blend = plain.blend;
    if (plain.writeMask !== undefined) this.writeMask = plain.writeMask;
  }
}

export type ToComputePipelineDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  layout?: Deno.PointerValue | PipelineLayout;
  compute?: ProgrammableStageDescriptor | ToProgrammableStageDescriptor;
};

export class ComputePipelineDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(64));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(64),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get layout(): PipelineLayout {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return new PipelineLayout(ptr);
  }

  set layout(value: Deno.PointerValue | PipelineLayout) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get compute(): ProgrammableStageDescriptor {
    return new ProgrammableStageDescriptor(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 24, 40),
    );
  }

  set compute(
    value: ProgrammableStageDescriptor | ToProgrammableStageDescriptor,
  ) {
    if (value instanceof ProgrammableStageDescriptor) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 40).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.compute.set(value);
    }
  }

  static from(plain: ToComputePipelineDescriptor) {
    const struct = new ComputePipelineDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.layout !== undefined) struct.layout = plain.layout;
    if (plain.compute !== undefined) struct.compute = plain.compute;
    return struct;
  }
  set(plain: ToComputePipelineDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.layout !== undefined) this.layout = plain.layout;
    if (plain.compute !== undefined) this.compute = plain.compute;
  }
}

export type ToDeviceDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  requiredFeaturesCount?: bigint | number;
  requiredFeatures?: Deno.PointerValue;
  requiredLimits?: Deno.PointerValue | RequiredLimits | ToRequiredLimits;
  defaultQueue?: QueueDescriptor | ToQueueDescriptor;
  deviceLostCallback?: Deno.PointerValue;
  deviceLostUserdata?: Deno.PointerValue;
};

export class DeviceDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(72));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(72),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get requiredFeaturesCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set requiredFeaturesCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get requiredFeatures(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set requiredFeatures(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get requiredLimits(): RequiredLimits | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new RequiredLimits(ptr);
  }

  set requiredLimits(
    value: Deno.PointerValue | RequiredLimits | ToRequiredLimits,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : RequiredLimits.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get defaultQueue(): QueueDescriptor {
    return new QueueDescriptor(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 40, 16),
    );
  }

  set defaultQueue(value: QueueDescriptor | ToQueueDescriptor) {
    if (value instanceof QueueDescriptor) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.defaultQueue.set(value);
    }
  }

  get deviceLostCallback(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(56, U.LE));
    return ptr;
  }

  set deviceLostCallback(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      56,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get deviceLostUserdata(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(64, U.LE));
    return ptr;
  }

  set deviceLostUserdata(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      64,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToDeviceDescriptor) {
    const struct = new DeviceDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.requiredFeaturesCount !== undefined) {
      struct.requiredFeaturesCount = plain.requiredFeaturesCount;
    }
    if (plain.requiredFeatures !== undefined) {
      struct.requiredFeatures = plain.requiredFeatures;
    }
    if (plain.requiredLimits !== undefined) {
      struct.requiredLimits = plain.requiredLimits;
    }
    if (plain.defaultQueue !== undefined) {
      struct.defaultQueue = plain.defaultQueue;
    }
    if (plain.deviceLostCallback !== undefined) {
      struct.deviceLostCallback = plain.deviceLostCallback;
    }
    if (plain.deviceLostUserdata !== undefined) {
      struct.deviceLostUserdata = plain.deviceLostUserdata;
    }
    return struct;
  }
  set(plain: ToDeviceDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.requiredFeaturesCount !== undefined) {
      this.requiredFeaturesCount = plain.requiredFeaturesCount;
    }
    if (plain.requiredFeatures !== undefined) {
      this.requiredFeatures = plain.requiredFeatures;
    }
    if (plain.requiredLimits !== undefined) {
      this.requiredLimits = plain.requiredLimits;
    }
    if (plain.defaultQueue !== undefined) {
      this.defaultQueue = plain.defaultQueue;
    }
    if (plain.deviceLostCallback !== undefined) {
      this.deviceLostCallback = plain.deviceLostCallback;
    }
    if (plain.deviceLostUserdata !== undefined) {
      this.deviceLostUserdata = plain.deviceLostUserdata;
    }
  }
}

export type ToRenderPassDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  colorAttachmentCount?: bigint | number;
  colorAttachments?:
    | Deno.PointerValue
    | RenderPassColorAttachment
    | ToRenderPassColorAttachment;
  depthStencilAttachment?:
    | Deno.PointerValue
    | RenderPassDepthStencilAttachment
    | ToRenderPassDepthStencilAttachment;
  occlusionQuerySet?: Deno.PointerValue | QuerySet;
  timestampWriteCount?: bigint | number;
  timestampWrites?:
    | Deno.PointerValue
    | RenderPassTimestampWrite
    | ToRenderPassTimestampWrite;
};

export class RenderPassDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(64));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(64),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get colorAttachmentCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set colorAttachmentCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get colorAttachments(): RenderPassColorAttachment | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new RenderPassColorAttachment(ptr);
  }

  set colorAttachments(
    value:
      | Deno.PointerValue
      | RenderPassColorAttachment
      | ToRenderPassColorAttachment,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : RenderPassColorAttachment.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get depthStencilAttachment(): RenderPassDepthStencilAttachment | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new RenderPassDepthStencilAttachment(ptr);
  }

  set depthStencilAttachment(
    value:
      | Deno.PointerValue
      | RenderPassDepthStencilAttachment
      | ToRenderPassDepthStencilAttachment,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : RenderPassDepthStencilAttachment.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get occlusionQuerySet(): QuerySet {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(40, U.LE));
    return new QuerySet(ptr);
  }

  set occlusionQuerySet(value: Deno.PointerValue | QuerySet) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      40,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get timestampWriteCount(): bigint {
    return this.dataview.getBigUint64(48, U.LE);
  }

  set timestampWriteCount(value: bigint | number) {
    this.dataview.setBigUint64(48, BigInt(value), U.LE);
  }

  get timestampWrites(): RenderPassTimestampWrite | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(56, U.LE));
    if (ptr == null) return null;
    else return new RenderPassTimestampWrite(ptr);
  }

  set timestampWrites(
    value:
      | Deno.PointerValue
      | RenderPassTimestampWrite
      | ToRenderPassTimestampWrite,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : RenderPassTimestampWrite.from(value).pointer;
    this.dataview.setBigUint64(
      56,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToRenderPassDescriptor) {
    const struct = new RenderPassDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.colorAttachmentCount !== undefined) {
      struct.colorAttachmentCount = plain.colorAttachmentCount;
    }
    if (plain.colorAttachments !== undefined) {
      struct.colorAttachments = plain.colorAttachments;
    }
    if (plain.depthStencilAttachment !== undefined) {
      struct.depthStencilAttachment = plain.depthStencilAttachment;
    }
    if (plain.occlusionQuerySet !== undefined) {
      struct.occlusionQuerySet = plain.occlusionQuerySet;
    }
    if (plain.timestampWriteCount !== undefined) {
      struct.timestampWriteCount = plain.timestampWriteCount;
    }
    if (plain.timestampWrites !== undefined) {
      struct.timestampWrites = plain.timestampWrites;
    }
    return struct;
  }
  set(plain: ToRenderPassDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.colorAttachmentCount !== undefined) {
      this.colorAttachmentCount = plain.colorAttachmentCount;
    }
    if (plain.colorAttachments !== undefined) {
      this.colorAttachments = plain.colorAttachments;
    }
    if (plain.depthStencilAttachment !== undefined) {
      this.depthStencilAttachment = plain.depthStencilAttachment;
    }
    if (plain.occlusionQuerySet !== undefined) {
      this.occlusionQuerySet = plain.occlusionQuerySet;
    }
    if (plain.timestampWriteCount !== undefined) {
      this.timestampWriteCount = plain.timestampWriteCount;
    }
    if (plain.timestampWrites !== undefined) {
      this.timestampWrites = plain.timestampWrites;
    }
  }
}

export type ToVertexState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  module?: Deno.PointerValue | ShaderModule;
  entryPoint?: Deno.PointerValue;
  constantCount?: bigint | number;
  constants?: Deno.PointerValue | ConstantEntry | ToConstantEntry;
  bufferCount?: bigint | number;
  buffers?: Deno.PointerValue | VertexBufferLayout | ToVertexBufferLayout;
};

export class VertexState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(56));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(56),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get module(): ShaderModule {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new ShaderModule(ptr);
  }

  set module(value: Deno.PointerValue | ShaderModule) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryPoint(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set entryPoint(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get constantCount(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set constantCount(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get constants(): ConstantEntry | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new ConstantEntry(ptr);
  }

  set constants(value: Deno.PointerValue | ConstantEntry | ToConstantEntry) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ConstantEntry.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get bufferCount(): bigint {
    return this.dataview.getBigUint64(40, U.LE);
  }

  set bufferCount(value: bigint | number) {
    this.dataview.setBigUint64(40, BigInt(value), U.LE);
  }

  get buffers(): VertexBufferLayout | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(48, U.LE));
    if (ptr == null) return null;
    else return new VertexBufferLayout(ptr);
  }

  set buffers(
    value: Deno.PointerValue | VertexBufferLayout | ToVertexBufferLayout,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : VertexBufferLayout.from(value).pointer;
    this.dataview.setBigUint64(
      48,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToVertexState) {
    const struct = new VertexState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) struct.module = plain.module;
    if (plain.entryPoint !== undefined) struct.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      struct.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) struct.constants = plain.constants;
    if (plain.bufferCount !== undefined) struct.bufferCount = plain.bufferCount;
    if (plain.buffers !== undefined) struct.buffers = plain.buffers;
    return struct;
  }
  set(plain: ToVertexState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) this.module = plain.module;
    if (plain.entryPoint !== undefined) this.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      this.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) this.constants = plain.constants;
    if (plain.bufferCount !== undefined) this.bufferCount = plain.bufferCount;
    if (plain.buffers !== undefined) this.buffers = plain.buffers;
  }
}

export type ToFragmentState = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  module?: Deno.PointerValue | ShaderModule;
  entryPoint?: Deno.PointerValue;
  constantCount?: bigint | number;
  constants?: Deno.PointerValue | ConstantEntry | ToConstantEntry;
  targetCount?: bigint | number;
  targets?: Deno.PointerValue | ColorTargetState | ToColorTargetState;
};

export class FragmentState extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(56));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(56),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get module(): ShaderModule {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return new ShaderModule(ptr);
  }

  set module(value: Deno.PointerValue | ShaderModule) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get entryPoint(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set entryPoint(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get constantCount(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set constantCount(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get constants(): ConstantEntry | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    if (ptr == null) return null;
    else return new ConstantEntry(ptr);
  }

  set constants(value: Deno.PointerValue | ConstantEntry | ToConstantEntry) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ConstantEntry.from(value).pointer;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get targetCount(): bigint {
    return this.dataview.getBigUint64(40, U.LE);
  }

  set targetCount(value: bigint | number) {
    this.dataview.setBigUint64(40, BigInt(value), U.LE);
  }

  get targets(): ColorTargetState | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(48, U.LE));
    if (ptr == null) return null;
    else return new ColorTargetState(ptr);
  }

  set targets(
    value: Deno.PointerValue | ColorTargetState | ToColorTargetState,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ColorTargetState.from(value).pointer;
    this.dataview.setBigUint64(
      48,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToFragmentState) {
    const struct = new FragmentState();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) struct.module = plain.module;
    if (plain.entryPoint !== undefined) struct.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      struct.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) struct.constants = plain.constants;
    if (plain.targetCount !== undefined) struct.targetCount = plain.targetCount;
    if (plain.targets !== undefined) struct.targets = plain.targets;
    return struct;
  }
  set(plain: ToFragmentState) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.module !== undefined) this.module = plain.module;
    if (plain.entryPoint !== undefined) this.entryPoint = plain.entryPoint;
    if (plain.constantCount !== undefined) {
      this.constantCount = plain.constantCount;
    }
    if (plain.constants !== undefined) this.constants = plain.constants;
    if (plain.targetCount !== undefined) this.targetCount = plain.targetCount;
    if (plain.targets !== undefined) this.targets = plain.targets;
  }
}

export type ToRenderPipelineDescriptor = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  label?: Deno.PointerValue;
  layout?: Deno.PointerValue | PipelineLayout;
  vertex?: VertexState | ToVertexState;
  primitive?: PrimitiveState | ToPrimitiveState;
  depthStencil?: Deno.PointerValue | DepthStencilState | ToDepthStencilState;
  multisample?: MultisampleState | ToMultisampleState;
  fragment?: Deno.PointerValue | FragmentState | ToFragmentState;
};

export class RenderPipelineDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(144));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(144),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get label(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set label(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get layout(): PipelineLayout {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return new PipelineLayout(ptr);
  }

  set layout(value: Deno.PointerValue | PipelineLayout) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get vertex(): VertexState {
    return new VertexState(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 24, 56),
    );
  }

  set vertex(value: VertexState | ToVertexState) {
    if (value instanceof VertexState) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 56).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.vertex.set(value);
    }
  }

  get primitive(): PrimitiveState {
    return new PrimitiveState(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 80, 24),
    );
  }

  set primitive(value: PrimitiveState | ToPrimitiveState) {
    if (value instanceof PrimitiveState) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.primitive.set(value);
    }
  }

  get depthStencil(): DepthStencilState | null {
    const ptr = Deno.UnsafePointer.create(
      this.dataview.getBigUint64(104, U.LE),
    );
    if (ptr == null) return null;
    else return new DepthStencilState(ptr);
  }

  set depthStencil(
    value: Deno.PointerValue | DepthStencilState | ToDepthStencilState,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : DepthStencilState.from(value).pointer;
    this.dataview.setBigUint64(
      104,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get multisample(): MultisampleState {
    return new MultisampleState(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 112, 24),
    );
  }

  set multisample(value: MultisampleState | ToMultisampleState) {
    if (value instanceof MultisampleState) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 24).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.multisample.set(value);
    }
  }

  get fragment(): FragmentState | null {
    const ptr = Deno.UnsafePointer.create(
      this.dataview.getBigUint64(136, U.LE),
    );
    if (ptr == null) return null;
    else return new FragmentState(ptr);
  }

  set fragment(value: Deno.PointerValue | FragmentState | ToFragmentState) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : FragmentState.from(value).pointer;
    this.dataview.setBigUint64(
      136,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToRenderPipelineDescriptor) {
    const struct = new RenderPipelineDescriptor();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) struct.label = plain.label;
    if (plain.layout !== undefined) struct.layout = plain.layout;
    if (plain.vertex !== undefined) struct.vertex = plain.vertex;
    if (plain.primitive !== undefined) struct.primitive = plain.primitive;
    if (plain.depthStencil !== undefined) {
      struct.depthStencil = plain.depthStencil;
    }
    if (plain.multisample !== undefined) struct.multisample = plain.multisample;
    if (plain.fragment !== undefined) struct.fragment = plain.fragment;
    return struct;
  }
  set(plain: ToRenderPipelineDescriptor) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.label !== undefined) this.label = plain.label;
    if (plain.layout !== undefined) this.layout = plain.layout;
    if (plain.vertex !== undefined) this.vertex = plain.vertex;
    if (plain.primitive !== undefined) this.primitive = plain.primitive;
    if (plain.depthStencil !== undefined) {
      this.depthStencil = plain.depthStencil;
    }
    if (plain.multisample !== undefined) this.multisample = plain.multisample;
    if (plain.fragment !== undefined) this.fragment = plain.fragment;
  }
}

export type ToChainedStruct = {
  next?: Deno.PointerValue | ChainedStruct | ToChainedStruct;
  sType: SType;
};

export class ChainedStruct extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get next(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set next(value: Deno.PointerValue | ChainedStruct | ToChainedStruct) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ChainedStruct.from(value).pointer;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get sType(): SType {
    return this.dataview.getUint32(8, U.LE) as SType;
  }

  set sType(value: SType) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToChainedStruct) {
    const struct = new ChainedStruct();
    if (plain === undefined) return struct;
    if (plain.next !== undefined) struct.next = plain.next;
    if (plain.sType !== undefined) struct.sType = plain.sType;
    return struct;
  }
  set(plain: ToChainedStruct) {
    if (plain === undefined) return;
    if (plain.next !== undefined) this.next = plain.next;
    if (plain.sType !== undefined) this.sType = plain.sType;
  }
}

export type ToChainedStructOut = {
  next?: Deno.PointerValue | ChainedStructOut | ToChainedStructOut;
  sType: SType;
};

export class ChainedStructOut extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get next(): ChainedStructOut | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStructOut(ptr);
  }

  set next(value: Deno.PointerValue | ChainedStructOut | ToChainedStructOut) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ChainedStructOut.from(value).pointer;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get sType(): SType {
    return this.dataview.getUint32(8, U.LE) as SType;
  }

  set sType(value: SType) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToChainedStructOut) {
    const struct = new ChainedStructOut();
    if (plain === undefined) return struct;
    if (plain.next !== undefined) struct.next = plain.next;
    if (plain.sType !== undefined) struct.sType = plain.sType;
    return struct;
  }
  set(plain: ToChainedStructOut) {
    if (plain === undefined) return;
    if (plain.next !== undefined) this.next = plain.next;
    if (plain.sType !== undefined) this.sType = plain.sType;
  }
}

export type ToInstanceExtras = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  backends?: number;
  dx12ShaderCompiler?: Dx12Compiler;
  dxilPath?: Deno.PointerValue;
  dxcPath?: Deno.PointerValue;
};

export class InstanceExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
      this.chain.sType = SType.InstanceExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get backends(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set backends(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get dx12ShaderCompiler(): Dx12Compiler {
    return this.dataview.getUint32(20, U.LE) as Dx12Compiler;
  }

  set dx12ShaderCompiler(value: Dx12Compiler) {
    this.dataview.setUint32(20, value, U.LE);
  }

  get dxilPath(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set dxilPath(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get dxcPath(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    return ptr;
  }

  set dxcPath(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToInstanceExtras) {
    const struct = new InstanceExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.backends !== undefined) struct.backends = plain.backends;
    if (plain.dx12ShaderCompiler !== undefined) {
      struct.dx12ShaderCompiler = plain.dx12ShaderCompiler;
    }
    if (plain.dxilPath !== undefined) struct.dxilPath = plain.dxilPath;
    if (plain.dxcPath !== undefined) struct.dxcPath = plain.dxcPath;
    return struct;
  }
  set(plain: ToInstanceExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.backends !== undefined) this.backends = plain.backends;
    if (plain.dx12ShaderCompiler !== undefined) {
      this.dx12ShaderCompiler = plain.dx12ShaderCompiler;
    }
    if (plain.dxilPath !== undefined) this.dxilPath = plain.dxilPath;
    if (plain.dxcPath !== undefined) this.dxcPath = plain.dxcPath;
  }
}

export type ToDeviceExtras = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  tracePath?: Deno.PointerValue;
};

export class DeviceExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.DeviceExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get tracePath(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(16, U.LE));
    return ptr;
  }

  set tracePath(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      16,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToDeviceExtras) {
    const struct = new DeviceExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.tracePath !== undefined) struct.tracePath = plain.tracePath;
    return struct;
  }
  set(plain: ToDeviceExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.tracePath !== undefined) this.tracePath = plain.tracePath;
  }
}

export type ToRequiredLimitsExtras = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  maxPushConstantSize?: number;
};

export class RequiredLimitsExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.RequiredLimitsExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get maxPushConstantSize(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set maxPushConstantSize(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  static from(plain: ToRequiredLimitsExtras) {
    const struct = new RequiredLimitsExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.maxPushConstantSize !== undefined) {
      struct.maxPushConstantSize = plain.maxPushConstantSize;
    }
    return struct;
  }
  set(plain: ToRequiredLimitsExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.maxPushConstantSize !== undefined) {
      this.maxPushConstantSize = plain.maxPushConstantSize;
    }
  }
}

export type ToSupportedLimitsExtras = undefined | {
  chain?: ChainedStructOut | ToChainedStructOut;
  maxPushConstantSize?: number;
};

export class SupportedLimitsExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(24));
      this.chain.sType = SType.SupportedLimitsExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(24),
        );
      }
    }
  }

  get chain(): ChainedStructOut {
    return new ChainedStructOut(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStructOut | ToChainedStructOut) {
    if (value instanceof ChainedStructOut) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get maxPushConstantSize(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set maxPushConstantSize(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  static from(plain: ToSupportedLimitsExtras) {
    const struct = new SupportedLimitsExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.maxPushConstantSize !== undefined) {
      struct.maxPushConstantSize = plain.maxPushConstantSize;
    }
    return struct;
  }
  set(plain: ToSupportedLimitsExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.maxPushConstantSize !== undefined) {
      this.maxPushConstantSize = plain.maxPushConstantSize;
    }
  }
}

export type ToPushConstantRange = undefined | {
  stages?: number;
  start?: number;
  end?: number;
};

export class PushConstantRange extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(12));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(12),
        );
      }
    }
  }

  get stages(): number {
    return this.dataview.getUint32(0, U.LE);
  }

  set stages(value: number) {
    this.dataview.setUint32(0, value, U.LE);
  }

  get start(): number {
    return this.dataview.getUint32(4, U.LE);
  }

  set start(value: number) {
    this.dataview.setUint32(4, value, U.LE);
  }

  get end(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set end(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToPushConstantRange) {
    const struct = new PushConstantRange();
    if (plain === undefined) return struct;
    if (plain.stages !== undefined) struct.stages = plain.stages;
    if (plain.start !== undefined) struct.start = plain.start;
    if (plain.end !== undefined) struct.end = plain.end;
    return struct;
  }
  set(plain: ToPushConstantRange) {
    if (plain === undefined) return;
    if (plain.stages !== undefined) this.stages = plain.stages;
    if (plain.start !== undefined) this.start = plain.start;
    if (plain.end !== undefined) this.end = plain.end;
  }
}

export type ToPipelineLayoutExtras = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  pushConstantRangeCount?: number;
  pushConstantRanges?:
    | Deno.PointerValue
    | PushConstantRange
    | ToPushConstantRange;
};

export class PipelineLayoutExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
      this.chain.sType = SType.PipelineLayoutExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get pushConstantRangeCount(): number {
    return this.dataview.getUint32(16, U.LE);
  }

  set pushConstantRangeCount(value: number) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get pushConstantRanges(): PushConstantRange | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    if (ptr == null) return null;
    else return new PushConstantRange(ptr);
  }

  set pushConstantRanges(
    value: Deno.PointerValue | PushConstantRange | ToPushConstantRange,
  ) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : PushConstantRange.from(value).pointer;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToPipelineLayoutExtras) {
    const struct = new PipelineLayoutExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.pushConstantRangeCount !== undefined) {
      struct.pushConstantRangeCount = plain.pushConstantRangeCount;
    }
    if (plain.pushConstantRanges !== undefined) {
      struct.pushConstantRanges = plain.pushConstantRanges;
    }
    return struct;
  }
  set(plain: ToPipelineLayoutExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.pushConstantRangeCount !== undefined) {
      this.pushConstantRangeCount = plain.pushConstantRangeCount;
    }
    if (plain.pushConstantRanges !== undefined) {
      this.pushConstantRanges = plain.pushConstantRanges;
    }
  }
}

export type ToWrappedSubmissionIndex = undefined | {
  queue?: Deno.PointerValue | Queue;
  submissionIndex?: bigint | number;
};

export class WrappedSubmissionIndex extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get queue(): Queue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return new Queue(ptr);
  }

  set queue(value: Deno.PointerValue | Queue) {
    const inner = value instanceof U.ClassBase ? value.pointer : value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get submissionIndex(): bigint {
    return this.dataview.getBigUint64(8, U.LE);
  }

  set submissionIndex(value: bigint | number) {
    this.dataview.setBigUint64(8, BigInt(value), U.LE);
  }

  static from(plain: ToWrappedSubmissionIndex) {
    const struct = new WrappedSubmissionIndex();
    if (plain === undefined) return struct;
    if (plain.queue !== undefined) struct.queue = plain.queue;
    if (plain.submissionIndex !== undefined) {
      struct.submissionIndex = plain.submissionIndex;
    }
    return struct;
  }
  set(plain: ToWrappedSubmissionIndex) {
    if (plain === undefined) return;
    if (plain.queue !== undefined) this.queue = plain.queue;
    if (plain.submissionIndex !== undefined) {
      this.submissionIndex = plain.submissionIndex;
    }
  }
}

export type ToShaderDefine = undefined | {
  name?: Deno.PointerValue;
  value?: Deno.PointerValue;
};

export class ShaderDefine extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get name(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    return ptr;
  }

  set name(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get value(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set value(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderDefine) {
    const struct = new ShaderDefine();
    if (plain === undefined) return struct;
    if (plain.name !== undefined) struct.name = plain.name;
    if (plain.value !== undefined) struct.value = plain.value;
    return struct;
  }
  set(plain: ToShaderDefine) {
    if (plain === undefined) return;
    if (plain.name !== undefined) this.name = plain.name;
    if (plain.value !== undefined) this.value = plain.value;
  }
}

export type ToShaderModuleGLSLDescriptor = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  stage?: ShaderStage;
  code?: Deno.PointerValue;
  defineCount?: number;
  defines?: Deno.PointerValue | ShaderDefine | ToShaderDefine;
};

export class ShaderModuleGLSLDescriptor extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(48));
      this.chain.sType = SType.ShaderModuleGLSLDescriptor;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(48),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get stage(): ShaderStage {
    return this.dataview.getUint32(16, U.LE) as ShaderStage;
  }

  set stage(value: ShaderStage) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get code(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set code(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get defineCount(): number {
    return this.dataview.getUint32(32, U.LE);
  }

  set defineCount(value: number) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get defines(): ShaderDefine | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(40, U.LE));
    if (ptr == null) return null;
    else return new ShaderDefine(ptr);
  }

  set defines(value: Deno.PointerValue | ShaderDefine | ToShaderDefine) {
    const inner = value instanceof U.StructBase
      ? value.pointer
      : U.duckIsPointer(value)
      ? value
      : ShaderDefine.from(value).pointer;
    this.dataview.setBigUint64(
      40,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToShaderModuleGLSLDescriptor) {
    const struct = new ShaderModuleGLSLDescriptor();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.stage !== undefined) struct.stage = plain.stage;
    if (plain.code !== undefined) struct.code = plain.code;
    if (plain.defineCount !== undefined) struct.defineCount = plain.defineCount;
    if (plain.defines !== undefined) struct.defines = plain.defines;
    return struct;
  }
  set(plain: ToShaderModuleGLSLDescriptor) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.stage !== undefined) this.stage = plain.stage;
    if (plain.code !== undefined) this.code = plain.code;
    if (plain.defineCount !== undefined) this.defineCount = plain.defineCount;
    if (plain.defines !== undefined) this.defines = plain.defines;
  }
}

export type ToStorageReport = undefined | {
  numOccupied?: bigint | number;
  numVacant?: bigint | number;
  numError?: bigint | number;
  elementSize?: bigint | number;
};

export class StorageReport extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(32));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(32),
        );
      }
    }
  }

  get numOccupied(): bigint {
    return this.dataview.getBigUint64(0, U.LE);
  }

  set numOccupied(value: bigint | number) {
    this.dataview.setBigUint64(0, BigInt(value), U.LE);
  }

  get numVacant(): bigint {
    return this.dataview.getBigUint64(8, U.LE);
  }

  set numVacant(value: bigint | number) {
    this.dataview.setBigUint64(8, BigInt(value), U.LE);
  }

  get numError(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set numError(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get elementSize(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set elementSize(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  static from(plain: ToStorageReport) {
    const struct = new StorageReport();
    if (plain === undefined) return struct;
    if (plain.numOccupied !== undefined) struct.numOccupied = plain.numOccupied;
    if (plain.numVacant !== undefined) struct.numVacant = plain.numVacant;
    if (plain.numError !== undefined) struct.numError = plain.numError;
    if (plain.elementSize !== undefined) struct.elementSize = plain.elementSize;
    return struct;
  }
  set(plain: ToStorageReport) {
    if (plain === undefined) return;
    if (plain.numOccupied !== undefined) this.numOccupied = plain.numOccupied;
    if (plain.numVacant !== undefined) this.numVacant = plain.numVacant;
    if (plain.numError !== undefined) this.numError = plain.numError;
    if (plain.elementSize !== undefined) this.elementSize = plain.elementSize;
  }
}

export type ToHubReport = undefined | {
  adapters?: StorageReport | ToStorageReport;
  devices?: StorageReport | ToStorageReport;
  pipelineLayouts?: StorageReport | ToStorageReport;
  shaderModules?: StorageReport | ToStorageReport;
  bindGroupLayouts?: StorageReport | ToStorageReport;
  bindGroups?: StorageReport | ToStorageReport;
  commandBuffers?: StorageReport | ToStorageReport;
  renderBundles?: StorageReport | ToStorageReport;
  renderPipelines?: StorageReport | ToStorageReport;
  computePipelines?: StorageReport | ToStorageReport;
  querySets?: StorageReport | ToStorageReport;
  buffers?: StorageReport | ToStorageReport;
  textures?: StorageReport | ToStorageReport;
  textureViews?: StorageReport | ToStorageReport;
  samplers?: StorageReport | ToStorageReport;
};

export class HubReport extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(480));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(480),
        );
      }
    }
  }

  get adapters(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 32),
    );
  }

  set adapters(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.adapters.set(value);
    }
  }

  get devices(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 32, 32),
    );
  }

  set devices(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.devices.set(value);
    }
  }

  get pipelineLayouts(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 64, 32),
    );
  }

  set pipelineLayouts(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.pipelineLayouts.set(value);
    }
  }

  get shaderModules(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 96, 32),
    );
  }

  set shaderModules(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.shaderModules.set(value);
    }
  }

  get bindGroupLayouts(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 128, 32),
    );
  }

  set bindGroupLayouts(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.bindGroupLayouts.set(value);
    }
  }

  get bindGroups(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 160, 32),
    );
  }

  set bindGroups(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.bindGroups.set(value);
    }
  }

  get commandBuffers(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 192, 32),
    );
  }

  set commandBuffers(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.commandBuffers.set(value);
    }
  }

  get renderBundles(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 224, 32),
    );
  }

  set renderBundles(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.renderBundles.set(value);
    }
  }

  get renderPipelines(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 256, 32),
    );
  }

  set renderPipelines(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.renderPipelines.set(value);
    }
  }

  get computePipelines(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 288, 32),
    );
  }

  set computePipelines(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.computePipelines.set(value);
    }
  }

  get querySets(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 320, 32),
    );
  }

  set querySets(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.querySets.set(value);
    }
  }

  get buffers(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 352, 32),
    );
  }

  set buffers(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.buffers.set(value);
    }
  }

  get textures(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 384, 32),
    );
  }

  set textures(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.textures.set(value);
    }
  }

  get textureViews(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 416, 32),
    );
  }

  set textureViews(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.textureViews.set(value);
    }
  }

  get samplers(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 448, 32),
    );
  }

  set samplers(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.samplers.set(value);
    }
  }

  static from(plain: ToHubReport) {
    const struct = new HubReport();
    if (plain === undefined) return struct;
    if (plain.adapters !== undefined) struct.adapters = plain.adapters;
    if (plain.devices !== undefined) struct.devices = plain.devices;
    if (plain.pipelineLayouts !== undefined) {
      struct.pipelineLayouts = plain.pipelineLayouts;
    }
    if (plain.shaderModules !== undefined) {
      struct.shaderModules = plain.shaderModules;
    }
    if (plain.bindGroupLayouts !== undefined) {
      struct.bindGroupLayouts = plain.bindGroupLayouts;
    }
    if (plain.bindGroups !== undefined) struct.bindGroups = plain.bindGroups;
    if (plain.commandBuffers !== undefined) {
      struct.commandBuffers = plain.commandBuffers;
    }
    if (plain.renderBundles !== undefined) {
      struct.renderBundles = plain.renderBundles;
    }
    if (plain.renderPipelines !== undefined) {
      struct.renderPipelines = plain.renderPipelines;
    }
    if (plain.computePipelines !== undefined) {
      struct.computePipelines = plain.computePipelines;
    }
    if (plain.querySets !== undefined) struct.querySets = plain.querySets;
    if (plain.buffers !== undefined) struct.buffers = plain.buffers;
    if (plain.textures !== undefined) struct.textures = plain.textures;
    if (plain.textureViews !== undefined) {
      struct.textureViews = plain.textureViews;
    }
    if (plain.samplers !== undefined) struct.samplers = plain.samplers;
    return struct;
  }
  set(plain: ToHubReport) {
    if (plain === undefined) return;
    if (plain.adapters !== undefined) this.adapters = plain.adapters;
    if (plain.devices !== undefined) this.devices = plain.devices;
    if (plain.pipelineLayouts !== undefined) {
      this.pipelineLayouts = plain.pipelineLayouts;
    }
    if (plain.shaderModules !== undefined) {
      this.shaderModules = plain.shaderModules;
    }
    if (plain.bindGroupLayouts !== undefined) {
      this.bindGroupLayouts = plain.bindGroupLayouts;
    }
    if (plain.bindGroups !== undefined) this.bindGroups = plain.bindGroups;
    if (plain.commandBuffers !== undefined) {
      this.commandBuffers = plain.commandBuffers;
    }
    if (plain.renderBundles !== undefined) {
      this.renderBundles = plain.renderBundles;
    }
    if (plain.renderPipelines !== undefined) {
      this.renderPipelines = plain.renderPipelines;
    }
    if (plain.computePipelines !== undefined) {
      this.computePipelines = plain.computePipelines;
    }
    if (plain.querySets !== undefined) this.querySets = plain.querySets;
    if (plain.buffers !== undefined) this.buffers = plain.buffers;
    if (plain.textures !== undefined) this.textures = plain.textures;
    if (plain.textureViews !== undefined) {
      this.textureViews = plain.textureViews;
    }
    if (plain.samplers !== undefined) this.samplers = plain.samplers;
  }
}

export type ToGlobalReport = undefined | {
  surfaces?: StorageReport | ToStorageReport;
  backendType?: BackendType;
  vulkan?: HubReport | ToHubReport;
  metal?: HubReport | ToHubReport;
  dx12?: HubReport | ToHubReport;
  dx11?: HubReport | ToHubReport;
  gl?: HubReport | ToHubReport;
};

export class GlobalReport extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(2440));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(2440),
        );
      }
    }
  }

  get surfaces(): StorageReport {
    return new StorageReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 32),
    );
  }

  set surfaces(value: StorageReport | ToStorageReport) {
    if (value instanceof StorageReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 32).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.surfaces.set(value);
    }
  }

  get backendType(): BackendType {
    return this.dataview.getUint32(32, U.LE) as BackendType;
  }

  set backendType(value: BackendType) {
    this.dataview.setUint32(32, value, U.LE);
  }

  get vulkan(): HubReport {
    return new HubReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 40, 480),
    );
  }

  set vulkan(value: HubReport | ToHubReport) {
    if (value instanceof HubReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 480).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.vulkan.set(value);
    }
  }

  get metal(): HubReport {
    return new HubReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 520, 480),
    );
  }

  set metal(value: HubReport | ToHubReport) {
    if (value instanceof HubReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 480).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.metal.set(value);
    }
  }

  get dx12(): HubReport {
    return new HubReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 1000, 480),
    );
  }

  set dx12(value: HubReport | ToHubReport) {
    if (value instanceof HubReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 480).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.dx12.set(value);
    }
  }

  get dx11(): HubReport {
    return new HubReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 1480, 480),
    );
  }

  set dx11(value: HubReport | ToHubReport) {
    if (value instanceof HubReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 480).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.dx11.set(value);
    }
  }

  get gl(): HubReport {
    return new HubReport(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 1960, 480),
    );
  }

  set gl(value: HubReport | ToHubReport) {
    if (value instanceof HubReport) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 480).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.gl.set(value);
    }
  }

  static from(plain: ToGlobalReport) {
    const struct = new GlobalReport();
    if (plain === undefined) return struct;
    if (plain.surfaces !== undefined) struct.surfaces = plain.surfaces;
    if (plain.backendType !== undefined) struct.backendType = plain.backendType;
    if (plain.vulkan !== undefined) struct.vulkan = plain.vulkan;
    if (plain.metal !== undefined) struct.metal = plain.metal;
    if (plain.dx12 !== undefined) struct.dx12 = plain.dx12;
    if (plain.dx11 !== undefined) struct.dx11 = plain.dx11;
    if (plain.gl !== undefined) struct.gl = plain.gl;
    return struct;
  }
  set(plain: ToGlobalReport) {
    if (plain === undefined) return;
    if (plain.surfaces !== undefined) this.surfaces = plain.surfaces;
    if (plain.backendType !== undefined) this.backendType = plain.backendType;
    if (plain.vulkan !== undefined) this.vulkan = plain.vulkan;
    if (plain.metal !== undefined) this.metal = plain.metal;
    if (plain.dx12 !== undefined) this.dx12 = plain.dx12;
    if (plain.dx11 !== undefined) this.dx11 = plain.dx11;
    if (plain.gl !== undefined) this.gl = plain.gl;
  }
}

export type ToSurfaceCapabilities = undefined | {
  formatCount?: bigint | number;
  formats?: Deno.PointerValue;
  presentModeCount?: bigint | number;
  presentModes?: Deno.PointerValue;
  alphaModeCount?: bigint | number;
  alphaModes?: Deno.PointerValue;
};

export class SurfaceCapabilities extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(48));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(48),
        );
      }
    }
  }

  get formatCount(): bigint {
    return this.dataview.getBigUint64(0, U.LE);
  }

  set formatCount(value: bigint | number) {
    this.dataview.setBigUint64(0, BigInt(value), U.LE);
  }

  get formats(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(8, U.LE));
    return ptr;
  }

  set formats(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      8,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get presentModeCount(): bigint {
    return this.dataview.getBigUint64(16, U.LE);
  }

  set presentModeCount(value: bigint | number) {
    this.dataview.setBigUint64(16, BigInt(value), U.LE);
  }

  get presentModes(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(24, U.LE));
    return ptr;
  }

  set presentModes(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      24,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get alphaModeCount(): bigint {
    return this.dataview.getBigUint64(32, U.LE);
  }

  set alphaModeCount(value: bigint | number) {
    this.dataview.setBigUint64(32, BigInt(value), U.LE);
  }

  get alphaModes(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(40, U.LE));
    return ptr;
  }

  set alphaModes(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      40,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSurfaceCapabilities) {
    const struct = new SurfaceCapabilities();
    if (plain === undefined) return struct;
    if (plain.formatCount !== undefined) struct.formatCount = plain.formatCount;
    if (plain.formats !== undefined) struct.formats = plain.formats;
    if (plain.presentModeCount !== undefined) {
      struct.presentModeCount = plain.presentModeCount;
    }
    if (plain.presentModes !== undefined) {
      struct.presentModes = plain.presentModes;
    }
    if (plain.alphaModeCount !== undefined) {
      struct.alphaModeCount = plain.alphaModeCount;
    }
    if (plain.alphaModes !== undefined) struct.alphaModes = plain.alphaModes;
    return struct;
  }
  set(plain: ToSurfaceCapabilities) {
    if (plain === undefined) return;
    if (plain.formatCount !== undefined) this.formatCount = plain.formatCount;
    if (plain.formats !== undefined) this.formats = plain.formats;
    if (plain.presentModeCount !== undefined) {
      this.presentModeCount = plain.presentModeCount;
    }
    if (plain.presentModes !== undefined) {
      this.presentModes = plain.presentModes;
    }
    if (plain.alphaModeCount !== undefined) {
      this.alphaModeCount = plain.alphaModeCount;
    }
    if (plain.alphaModes !== undefined) this.alphaModes = plain.alphaModes;
  }
}

export type ToSwapChainDescriptorExtras = undefined | {
  chain?: ChainedStruct | ToChainedStruct;
  alphaMode?: CompositeAlphaMode;
  viewFormatCount?: bigint | number;
  viewFormats?: Deno.PointerValue;
};

export class SwapChainDescriptorExtras extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(40));
      this.chain.sType = SType.SwapChainDescriptorExtras;
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(40),
        );
      }
    }
  }

  get chain(): ChainedStruct {
    return new ChainedStruct(
      new DataView(this.dataview.buffer, this.dataview.byteOffset + 0, 16),
    );
  }

  set chain(value: ChainedStruct | ToChainedStruct) {
    if (value instanceof ChainedStruct) {
      const tv = this.dataview;
      const vv = value.dataview;
      new Uint8Array(tv.buffer, tv.byteOffset, 16).set(
        new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength),
      );
    } else {
      this.chain.set(value);
    }
  }

  get alphaMode(): CompositeAlphaMode {
    return this.dataview.getUint32(16, U.LE) as CompositeAlphaMode;
  }

  set alphaMode(value: CompositeAlphaMode) {
    this.dataview.setUint32(16, value, U.LE);
  }

  get viewFormatCount(): bigint {
    return this.dataview.getBigUint64(24, U.LE);
  }

  set viewFormatCount(value: bigint | number) {
    this.dataview.setBigUint64(24, BigInt(value), U.LE);
  }

  get viewFormats(): Deno.PointerValue {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(32, U.LE));
    return ptr;
  }

  set viewFormats(value: Deno.PointerValue) {
    const inner = value;
    this.dataview.setBigUint64(
      32,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  static from(plain: ToSwapChainDescriptorExtras) {
    const struct = new SwapChainDescriptorExtras();
    if (plain === undefined) return struct;
    if (plain.chain !== undefined) struct.chain = plain.chain;
    if (plain.alphaMode !== undefined) struct.alphaMode = plain.alphaMode;
    if (plain.viewFormatCount !== undefined) {
      struct.viewFormatCount = plain.viewFormatCount;
    }
    if (plain.viewFormats !== undefined) struct.viewFormats = plain.viewFormats;
    return struct;
  }
  set(plain: ToSwapChainDescriptorExtras) {
    if (plain === undefined) return;
    if (plain.chain !== undefined) this.chain = plain.chain;
    if (plain.alphaMode !== undefined) this.alphaMode = plain.alphaMode;
    if (plain.viewFormatCount !== undefined) {
      this.viewFormatCount = plain.viewFormatCount;
    }
    if (plain.viewFormats !== undefined) this.viewFormats = plain.viewFormats;
  }
}

export type ToInstanceEnumerateAdapterOptions = undefined | {
  nextInChain?: Deno.PointerValue | {
    chain: ChainedStruct | ToChainedStruct;
    [key: string]: any;
  };
  backends?: number;
};

export class InstanceEnumerateAdapterOptions extends U.StructBase {
  dataview: DataView;
  constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
    super();
    if (dataviewOrPtr === undefined) {
      this.dataview = new DataView(new ArrayBuffer(16));
    } else {
      if (dataviewOrPtr instanceof DataView) {
        this.dataview = dataviewOrPtr;
      } else {
        this.dataview = new DataView(
          new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(16),
        );
      }
    }
  }

  get nextInChain(): ChainedStruct | null {
    const ptr = Deno.UnsafePointer.create(this.dataview.getBigUint64(0, U.LE));
    if (ptr == null) return null;
    else return new ChainedStruct(ptr);
  }

  set nextInChain(
    value: Deno.PointerValue | {
      chain: ChainedStruct | ToChainedStruct;
      [key: string]: any;
    },
  ) {
    let inner!: Deno.PointerValue;
    if (U.duckIsPointer(value)) inner = value;
    else {
      if (value.chain.sType == SType.Invalid) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromMetalLayer) {
        inner = SurfaceDescriptorFromMetalLayer.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWindowsHWND) {
        inner = SurfaceDescriptorFromWindowsHWND.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXlibWindow) {
        inner = SurfaceDescriptorFromXlibWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromCanvasHTMLSelector) {
        inner = SurfaceDescriptorFromCanvasHTMLSelector.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleSPIRVDescriptor) {
        inner = ShaderModuleSPIRVDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleWGSLDescriptor) {
        inner = ShaderModuleWGSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.PrimitiveDepthClipControl) {
        inner = PrimitiveDepthClipControl.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromWaylandSurface) {
        inner = SurfaceDescriptorFromWaylandSurface.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromAndroidNativeWindow) {
        inner = SurfaceDescriptorFromAndroidNativeWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.SurfaceDescriptorFromXcbWindow) {
        inner = SurfaceDescriptorFromXcbWindow.from(value).pointer;
      }
      if (value.chain.sType == SType.RenderPassDescriptorMaxDrawCount) {
        inner = RenderPassDescriptorMaxDrawCount.from(value).pointer;
      }
      if (value.chain.sType == SType.DeviceExtras) {
        inner = DeviceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.AdapterExtras) {
        throw new Error(`Invalid sType ${value.chain.sType}`);
      }
      if (value.chain.sType == SType.RequiredLimitsExtras) {
        inner = RequiredLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.PipelineLayoutExtras) {
        inner = PipelineLayoutExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.ShaderModuleGLSLDescriptor) {
        inner = ShaderModuleGLSLDescriptor.from(value).pointer;
      }
      if (value.chain.sType == SType.SupportedLimitsExtras) {
        inner = SupportedLimitsExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.InstanceExtras) {
        inner = InstanceExtras.from(value).pointer;
      }
      if (value.chain.sType == SType.SwapChainDescriptorExtras) {
        inner = SwapChainDescriptorExtras.from(value).pointer;
      }
    }

    this.dataview.setBigUint64(
      0,
      BigInt(Deno.UnsafePointer.value(inner)),
      U.LE,
    );
  }

  get backends(): number {
    return this.dataview.getUint32(8, U.LE);
  }

  set backends(value: number) {
    this.dataview.setUint32(8, value, U.LE);
  }

  static from(plain: ToInstanceEnumerateAdapterOptions) {
    const struct = new InstanceEnumerateAdapterOptions();
    if (plain === undefined) return struct;
    if (plain.nextInChain !== undefined) struct.nextInChain = plain.nextInChain;
    if (plain.backends !== undefined) struct.backends = plain.backends;
    return struct;
  }
  set(plain: ToInstanceEnumerateAdapterOptions) {
    if (plain === undefined) return;
    if (plain.nextInChain !== undefined) this.nextInChain = plain.nextInChain;
    if (plain.backends !== undefined) this.backends = plain.backends;
  }
}

export const BufferMapCallback = {
  result: "void",
  parameters: ["u32", "pointer"],
} as const;

export const CompilationInfoCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer"],
} as const;

export const CreateComputePipelineAsyncCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer", "pointer"],
} as const;

export const CreateRenderPipelineAsyncCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer", "pointer"],
} as const;

export const DeviceLostCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer"],
} as const;

export const ErrorCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer"],
} as const;

export const QueueWorkDoneCallback = {
  result: "void",
  parameters: ["u32", "pointer"],
} as const;

export const RequestAdapterCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer", "pointer"],
} as const;

export const RequestDeviceCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer", "pointer"],
} as const;

export const ProcDeviceSetUncapturedErrorCallback = {
  result: "void",
  parameters: ["pointer", "pointer", "pointer"],
} as const;

export const LogCallback = {
  result: "void",
  parameters: ["u32", "pointer", "pointer"],
} as const;

export function createInstance(
  descriptor?:
    | InstanceDescriptor
    | null
    | ToInstanceDescriptor
    | Deno.PointerValue,
): Instance {
  const result = lib.symbols.wgpuCreateInstance(
    descriptor instanceof InstanceDescriptor
      ? descriptor.pointer
      : U.duckIsPointer(descriptor)
      ? descriptor
      : InstanceDescriptor.from(descriptor).pointer,
  );
  return new Instance(result);
}

export function getProcAddress(
  device: Device,
  procName: Deno.PointerValue,
): Deno.PointerValue {
  const result = lib.symbols.wgpuGetProcAddress(device.pointer, procName);
  return result;
}

export function generateReport(
  instance: Instance,
  report: GlobalReport | null | ToGlobalReport | Deno.PointerValue,
): void {
  const result = lib.symbols.wgpuGenerateReport(
    instance.pointer,
    report instanceof GlobalReport
      ? report.pointer
      : U.duckIsPointer(report)
      ? report
      : GlobalReport.from(report).pointer,
  );
  return result;
}

export function setLogCallback(): Promise<[LogLevel, Deno.PointerValue]>;
export function setLogCallback(
  callback: (...args: [LogLevel, Deno.PointerValue]) => void,
): Deno.UnsafeCallback<typeof LogCallback>;
export function setLogCallback(
  callback: Deno.UnsafeCallback<typeof LogCallback>,
): void;
export function setLogCallback(callback: Deno.PointerValue): void;
export function setLogCallback(
  callback?:
    | ((...args: [LogLevel, Deno.PointerValue]) => void)
    | Deno.UnsafeCallback<typeof LogCallback>
    | Deno.PointerValue,
):
  | void
  | Promise<[LogLevel, Deno.PointerValue]>
  | Deno.UnsafeCallback<typeof LogCallback> {
  if (callback == null) {
    return new Promise((res) => {
      const cb = new Deno.UnsafeCallback(
        LogCallback,
        (...args: U.CbParam<typeof LogCallback>) => {
          res([args[0] as LogLevel, args[1]]);
        },
      );
      lib.symbols.wgpuSetLogCallback(cb.pointer, null);
    });
  } else if (callback instanceof Deno.UnsafeCallback) {
    lib.symbols.wgpuSetLogCallback(callback.pointer, null);
  } else if (callback instanceof Function) {
    const cb = new Deno.UnsafeCallback(
      LogCallback,
      (...args: U.CbParam<typeof LogCallback>) => {
        callback(...[args[0] as LogLevel, args[1]]);
      },
    );
    lib.symbols.wgpuSetLogCallback(cb.pointer, null);
    return cb;
  } else {
    lib.symbols.wgpuSetLogCallback(callback, null);
  }
}

export function setLogLevel(level: LogLevel): void {
  const result = lib.symbols.wgpuSetLogLevel(level);
  return result;
}

export function getVersion(): number {
  const result = lib.symbols.wgpuGetVersion();
  return result;
}

export class Adapter extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuAdapterRelease]);
  }

  enumerateFeatures(features: Deno.PointerValue): number | bigint {
    const result = lib.symbols.wgpuAdapterEnumerateFeatures(
      this.pointer,
      features,
    );
    return result;
  }

  getLimits(
    limits?: SupportedLimits | null | ToSupportedLimits | Deno.PointerValue,
  ): boolean {
    const result = lib.symbols.wgpuAdapterGetLimits(
      this.pointer,
      limits instanceof SupportedLimits
        ? limits.pointer
        : U.duckIsPointer(limits)
        ? limits
        : SupportedLimits.from(limits).pointer,
    );
    return result == 1;
  }

  getProperties(
    properties?:
      | AdapterProperties
      | null
      | ToAdapterProperties
      | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuAdapterGetProperties(
      this.pointer,
      properties instanceof AdapterProperties
        ? properties.pointer
        : U.duckIsPointer(properties)
        ? properties
        : AdapterProperties.from(properties).pointer,
    );
    return result;
  }

  hasFeature(feature: FeatureName): boolean {
    const result = lib.symbols.wgpuAdapterHasFeature(this.pointer, feature);
    return result == 1;
  }

  requestDevice(
    descriptor?: DeviceDescriptor | null,
  ): Promise<[RequestDeviceStatus, Device, Deno.PointerValue]>;
  requestDevice(
    descriptor: DeviceDescriptor | null,
    callback: (
      ...args: [RequestDeviceStatus, Device, Deno.PointerValue]
    ) => void,
  ): Deno.UnsafeCallback<typeof RequestDeviceCallback>;
  requestDevice(
    descriptor: DeviceDescriptor | null,
    callback: Deno.UnsafeCallback<typeof RequestDeviceCallback>,
  ): void;
  requestDevice(
    descriptor: DeviceDescriptor | null,
    callback: Deno.PointerValue,
  ): void;
  requestDevice(
    descriptor: DeviceDescriptor | null,
    callback?:
      | ((...args: [RequestDeviceStatus, Device, Deno.PointerValue]) => void)
      | Deno.UnsafeCallback<typeof RequestDeviceCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[RequestDeviceStatus, Device, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof RequestDeviceCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          RequestDeviceCallback,
          (...args: U.CbParam<typeof RequestDeviceCallback>) => {
            res([
              args[0] as RequestDeviceStatus,
              new Device(args[1], this),
              args[2],
            ]);
          },
        );
        lib.symbols.wgpuAdapterRequestDevice(
          this.pointer,
          descriptor instanceof DeviceDescriptor
            ? descriptor.pointer
            : U.duckIsPointer(descriptor)
            ? descriptor
            : DeviceDescriptor.from(descriptor).pointer,
          cb.pointer,
          null,
        );
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuAdapterRequestDevice(
        this.pointer,
        descriptor instanceof DeviceDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : DeviceDescriptor.from(descriptor).pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        RequestDeviceCallback,
        (...args: U.CbParam<typeof RequestDeviceCallback>) => {
          callback(...[
            args[0] as RequestDeviceStatus,
            new Device(args[1], this),
            args[2],
          ]);
        },
      );
      lib.symbols.wgpuAdapterRequestDevice(
        this.pointer,
        descriptor instanceof DeviceDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : DeviceDescriptor.from(descriptor).pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuAdapterRequestDevice(
        this.pointer,
        descriptor instanceof DeviceDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : DeviceDescriptor.from(descriptor).pointer,
        callback,
        null,
      );
    }
  }
}

export class BindGroup extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuBindGroupRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuBindGroupSetLabel(this.pointer, label);
    return result;
  }
}

export class BindGroupLayout extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [
      pointer,
      lib.symbols.wgpuBindGroupLayoutRelease,
    ]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuBindGroupLayoutSetLabel(this.pointer, label);
    return result;
  }
}

export class Buffer extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuBufferRelease]);
  }

  destroy(): void {
    const result = lib.symbols.wgpuBufferDestroy(this.pointer);
    return result;
  }

  getConstMappedRange(
    offset: number | bigint,
    size: number | bigint,
  ): Deno.PointerValue {
    const result = lib.symbols.wgpuBufferGetConstMappedRange(
      this.pointer,
      offset,
      size,
    );
    return result;
  }

  getMapState(): BufferMapState {
    const result = lib.symbols.wgpuBufferGetMapState(this.pointer);
    return result as BufferMapState;
  }

  getMappedRange(
    offset: number | bigint,
    size: number | bigint,
  ): Deno.PointerValue {
    const result = lib.symbols.wgpuBufferGetMappedRange(
      this.pointer,
      offset,
      size,
    );
    return result;
  }

  getSize(): number | bigint {
    const result = lib.symbols.wgpuBufferGetSize(this.pointer);
    return result;
  }

  getUsage(): number {
    const result = lib.symbols.wgpuBufferGetUsage(this.pointer);
    return result;
  }

  mapAsync(
    mode: number,
    offset: number | bigint,
    size: number | bigint,
  ): Promise<[BufferMapAsyncStatus]>;
  mapAsync(
    mode: number,
    offset: number | bigint,
    size: number | bigint,
    callback: (...args: [BufferMapAsyncStatus]) => void,
  ): Deno.UnsafeCallback<typeof BufferMapCallback>;
  mapAsync(
    mode: number,
    offset: number | bigint,
    size: number | bigint,
    callback: Deno.UnsafeCallback<typeof BufferMapCallback>,
  ): void;
  mapAsync(
    mode: number,
    offset: number | bigint,
    size: number | bigint,
    callback: Deno.PointerValue,
  ): void;
  mapAsync(
    mode: number,
    offset: number | bigint,
    size: number | bigint,
    callback?:
      | ((...args: [BufferMapAsyncStatus]) => void)
      | Deno.UnsafeCallback<typeof BufferMapCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[BufferMapAsyncStatus]>
    | Deno.UnsafeCallback<typeof BufferMapCallback> {
    if (callback == null) {
      return new Promise((res) => {
        let data: [BufferMapAsyncStatus];
        const device = this.findInFamily(Device);
        if (!device) {
          throw new Error(
            "WGPU Object must be associated to Device to call async method.",
          );
        }
        const cb = new Deno.UnsafeCallback(
          BufferMapCallback,
          (...args: U.CbParam<typeof BufferMapCallback>) => {
            data = [args[0] as BufferMapAsyncStatus];
          },
        );
        lib.symbols.wgpuBufferMapAsync(
          this.pointer,
          mode,
          offset,
          size,
          cb.pointer,
          null,
        );
        const id = setInterval(() => {
          if (lib.symbols.wgpuDevicePoll(device.pointer, 0, null)) {
            clearInterval(id);
            res(data!);
          }
        }, 10);
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuBufferMapAsync(
        this.pointer,
        mode,
        offset,
        size,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        BufferMapCallback,
        (...args: U.CbParam<typeof BufferMapCallback>) => {
          callback(...[args[0] as BufferMapAsyncStatus]);
        },
      );
      lib.symbols.wgpuBufferMapAsync(
        this.pointer,
        mode,
        offset,
        size,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuBufferMapAsync(
        this.pointer,
        mode,
        offset,
        size,
        callback,
        null,
      );
    }
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuBufferSetLabel(this.pointer, label);
    return result;
  }

  unmap(): void {
    const result = lib.symbols.wgpuBufferUnmap(this.pointer);
    return result;
  }
}

export class CommandBuffer extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuCommandBufferRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuCommandBufferSetLabel(this.pointer, label);
    return result;
  }
}

export class CommandEncoder extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuCommandEncoderRelease]);
  }

  beginComputePass(
    descriptor?:
      | ComputePassDescriptor
      | null
      | ToComputePassDescriptor
      | Deno.PointerValue,
  ): ComputePassEncoder {
    const result = lib.symbols.wgpuCommandEncoderBeginComputePass(
      this.pointer,
      descriptor instanceof ComputePassDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : ComputePassDescriptor.from(descriptor).pointer,
    );
    return new ComputePassEncoder(result, this);
  }

  beginRenderPass(
    descriptor?:
      | RenderPassDescriptor
      | null
      | ToRenderPassDescriptor
      | Deno.PointerValue,
  ): RenderPassEncoder {
    const result = lib.symbols.wgpuCommandEncoderBeginRenderPass(
      this.pointer,
      descriptor instanceof RenderPassDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : RenderPassDescriptor.from(descriptor).pointer,
    );
    return new RenderPassEncoder(result, this);
  }

  clearBuffer(
    buffer: Buffer,
    offset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderClearBuffer(
      this.pointer,
      buffer.pointer,
      offset,
      size,
    );
    return result;
  }

  copyBufferToBuffer(
    source: Buffer,
    sourceOffset: number | bigint,
    destination: Buffer,
    destinationOffset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderCopyBufferToBuffer(
      this.pointer,
      source.pointer,
      sourceOffset,
      destination.pointer,
      destinationOffset,
      size,
    );
    return result;
  }

  copyBufferToTexture(
    source: ImageCopyBuffer | null | ToImageCopyBuffer | Deno.PointerValue,
    destination:
      | ImageCopyTexture
      | null
      | ToImageCopyTexture
      | Deno.PointerValue,
    copySize: Extent3D | null | ToExtent3D | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderCopyBufferToTexture(
      this.pointer,
      source instanceof ImageCopyBuffer
        ? source.pointer
        : U.duckIsPointer(source)
        ? source
        : ImageCopyBuffer.from(source).pointer,
      destination instanceof ImageCopyTexture
        ? destination.pointer
        : U.duckIsPointer(destination)
        ? destination
        : ImageCopyTexture.from(destination).pointer,
      copySize instanceof Extent3D
        ? copySize.pointer
        : U.duckIsPointer(copySize)
        ? copySize
        : Extent3D.from(copySize).pointer,
    );
    return result;
  }

  copyTextureToBuffer(
    source: ImageCopyTexture | null | ToImageCopyTexture | Deno.PointerValue,
    destination: ImageCopyBuffer | null | ToImageCopyBuffer | Deno.PointerValue,
    copySize: Extent3D | null | ToExtent3D | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderCopyTextureToBuffer(
      this.pointer,
      source instanceof ImageCopyTexture
        ? source.pointer
        : U.duckIsPointer(source)
        ? source
        : ImageCopyTexture.from(source).pointer,
      destination instanceof ImageCopyBuffer
        ? destination.pointer
        : U.duckIsPointer(destination)
        ? destination
        : ImageCopyBuffer.from(destination).pointer,
      copySize instanceof Extent3D
        ? copySize.pointer
        : U.duckIsPointer(copySize)
        ? copySize
        : Extent3D.from(copySize).pointer,
    );
    return result;
  }

  copyTextureToTexture(
    source: ImageCopyTexture | null | ToImageCopyTexture | Deno.PointerValue,
    destination:
      | ImageCopyTexture
      | null
      | ToImageCopyTexture
      | Deno.PointerValue,
    copySize: Extent3D | null | ToExtent3D | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderCopyTextureToTexture(
      this.pointer,
      source instanceof ImageCopyTexture
        ? source.pointer
        : U.duckIsPointer(source)
        ? source
        : ImageCopyTexture.from(source).pointer,
      destination instanceof ImageCopyTexture
        ? destination.pointer
        : U.duckIsPointer(destination)
        ? destination
        : ImageCopyTexture.from(destination).pointer,
      copySize instanceof Extent3D
        ? copySize.pointer
        : U.duckIsPointer(copySize)
        ? copySize
        : Extent3D.from(copySize).pointer,
    );
    return result;
  }

  finish(
    descriptor?:
      | CommandBufferDescriptor
      | null
      | ToCommandBufferDescriptor
      | Deno.PointerValue,
  ): CommandBuffer {
    const result = lib.symbols.wgpuCommandEncoderFinish(
      this.pointer,
      descriptor instanceof CommandBufferDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : CommandBufferDescriptor.from(descriptor).pointer,
    );
    return new CommandBuffer(result, this);
  }

  insertDebugMarker(markerLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuCommandEncoderInsertDebugMarker(
      this.pointer,
      markerLabel,
    );
    return result;
  }

  popDebugGroup(): void {
    const result = lib.symbols.wgpuCommandEncoderPopDebugGroup(this.pointer);
    return result;
  }

  pushDebugGroup(groupLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuCommandEncoderPushDebugGroup(
      this.pointer,
      groupLabel,
    );
    return result;
  }

  resolveQuerySet(
    querySet: QuerySet,
    firstQuery: number,
    queryCount: number,
    destination: Buffer,
    destinationOffset: number | bigint,
  ): void {
    const result = lib.symbols.wgpuCommandEncoderResolveQuerySet(
      this.pointer,
      querySet.pointer,
      firstQuery,
      queryCount,
      destination.pointer,
      destinationOffset,
    );
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuCommandEncoderSetLabel(this.pointer, label);
    return result;
  }

  writeTimestamp(querySet: QuerySet, queryIndex: number): void {
    const result = lib.symbols.wgpuCommandEncoderWriteTimestamp(
      this.pointer,
      querySet.pointer,
      queryIndex,
    );
    return result;
  }
}

export class ComputePassEncoder extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [
      pointer,
      lib.symbols.wgpuComputePassEncoderRelease,
    ]);
  }

  beginPipelineStatisticsQuery(querySet: QuerySet, queryIndex: number): void {
    const result = lib.symbols
      .wgpuComputePassEncoderBeginPipelineStatisticsQuery(
        this.pointer,
        querySet.pointer,
        queryIndex,
      );
    return result;
  }

  dispatchWorkgroups(
    workgroupCountX: number,
    workgroupCountY: number,
    workgroupCountZ: number,
  ): void {
    const result = lib.symbols.wgpuComputePassEncoderDispatchWorkgroups(
      this.pointer,
      workgroupCountX,
      workgroupCountY,
      workgroupCountZ,
    );
    return result;
  }

  dispatchWorkgroupsIndirect(
    indirectBuffer: Buffer,
    indirectOffset: number | bigint,
  ): void {
    const result = lib.symbols.wgpuComputePassEncoderDispatchWorkgroupsIndirect(
      this.pointer,
      indirectBuffer.pointer,
      indirectOffset,
    );
    return result;
  }

  end(): void {
    const result = lib.symbols.wgpuComputePassEncoderEnd(this.pointer);
    return result;
  }

  endPipelineStatisticsQuery(): void {
    const result = lib.symbols.wgpuComputePassEncoderEndPipelineStatisticsQuery(
      this.pointer,
    );
    return result;
  }

  insertDebugMarker(markerLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuComputePassEncoderInsertDebugMarker(
      this.pointer,
      markerLabel,
    );
    return result;
  }

  popDebugGroup(): void {
    const result = lib.symbols.wgpuComputePassEncoderPopDebugGroup(
      this.pointer,
    );
    return result;
  }

  pushDebugGroup(groupLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuComputePassEncoderPushDebugGroup(
      this.pointer,
      groupLabel,
    );
    return result;
  }

  setBindGroup(
    groupIndex: number,
    group: BindGroup,
    dynamicOffsetCount: number | bigint,
    dynamicOffsets: Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuComputePassEncoderSetBindGroup(
      this.pointer,
      groupIndex,
      group.pointer,
      dynamicOffsetCount,
      dynamicOffsets,
    );
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuComputePassEncoderSetLabel(
      this.pointer,
      label,
    );
    return result;
  }

  setPipeline(pipeline: ComputePipeline): void {
    const result = lib.symbols.wgpuComputePassEncoderSetPipeline(
      this.pointer,
      pipeline.pointer,
    );
    return result;
  }
}

export class ComputePipeline extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [
      pointer,
      lib.symbols.wgpuComputePipelineRelease,
    ]);
  }

  getBindGroupLayout(groupIndex: number): BindGroupLayout {
    const result = lib.symbols.wgpuComputePipelineGetBindGroupLayout(
      this.pointer,
      groupIndex,
    );
    return new BindGroupLayout(result, this);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuComputePipelineSetLabel(this.pointer, label);
    return result;
  }
}

export class Device extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuDeviceRelease]);
  }

  createBindGroup(
    descriptor?:
      | BindGroupDescriptor
      | null
      | ToBindGroupDescriptor
      | Deno.PointerValue,
  ): BindGroup {
    const result = lib.symbols.wgpuDeviceCreateBindGroup(
      this.pointer,
      descriptor instanceof BindGroupDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : BindGroupDescriptor.from(descriptor).pointer,
    );
    return new BindGroup(result, this);
  }

  createBindGroupLayout(
    descriptor?:
      | BindGroupLayoutDescriptor
      | null
      | ToBindGroupLayoutDescriptor
      | Deno.PointerValue,
  ): BindGroupLayout {
    const result = lib.symbols.wgpuDeviceCreateBindGroupLayout(
      this.pointer,
      descriptor instanceof BindGroupLayoutDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : BindGroupLayoutDescriptor.from(descriptor).pointer,
    );
    return new BindGroupLayout(result, this);
  }

  createBuffer(
    descriptor?:
      | BufferDescriptor
      | null
      | ToBufferDescriptor
      | Deno.PointerValue,
  ): Buffer {
    const result = lib.symbols.wgpuDeviceCreateBuffer(
      this.pointer,
      descriptor instanceof BufferDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : BufferDescriptor.from(descriptor).pointer,
    );
    return new Buffer(result, this);
  }

  createCommandEncoder(
    descriptor?:
      | CommandEncoderDescriptor
      | null
      | ToCommandEncoderDescriptor
      | Deno.PointerValue,
  ): CommandEncoder {
    const result = lib.symbols.wgpuDeviceCreateCommandEncoder(
      this.pointer,
      descriptor instanceof CommandEncoderDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : CommandEncoderDescriptor.from(descriptor).pointer,
    );
    return new CommandEncoder(result, this);
  }

  createComputePipeline(
    descriptor?:
      | ComputePipelineDescriptor
      | null
      | ToComputePipelineDescriptor
      | Deno.PointerValue,
  ): ComputePipeline {
    const result = lib.symbols.wgpuDeviceCreateComputePipeline(
      this.pointer,
      descriptor instanceof ComputePipelineDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : ComputePipelineDescriptor.from(descriptor).pointer,
    );
    return new ComputePipeline(result, this);
  }

  createComputePipelineAsync(
    descriptor?: ComputePipelineDescriptor | null,
  ): Promise<[CreatePipelineAsyncStatus, ComputePipeline, Deno.PointerValue]>;
  createComputePipelineAsync(
    descriptor: ComputePipelineDescriptor | null,
    callback: (
      ...args: [CreatePipelineAsyncStatus, ComputePipeline, Deno.PointerValue]
    ) => void,
  ): Deno.UnsafeCallback<typeof CreateComputePipelineAsyncCallback>;
  createComputePipelineAsync(
    descriptor: ComputePipelineDescriptor | null,
    callback: Deno.UnsafeCallback<typeof CreateComputePipelineAsyncCallback>,
  ): void;
  createComputePipelineAsync(
    descriptor: ComputePipelineDescriptor | null,
    callback: Deno.PointerValue,
  ): void;
  createComputePipelineAsync(
    descriptor: ComputePipelineDescriptor | null,
    callback?:
      | ((
        ...args: [CreatePipelineAsyncStatus, ComputePipeline, Deno.PointerValue]
      ) => void)
      | Deno.UnsafeCallback<typeof CreateComputePipelineAsyncCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[CreatePipelineAsyncStatus, ComputePipeline, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof CreateComputePipelineAsyncCallback> {
    if (callback == null) {
      return new Promise((res) => {
        let data: [
          CreatePipelineAsyncStatus,
          ComputePipeline,
          Deno.PointerValue,
        ];
        const device = this.findInFamily(Device);
        if (!device) {
          throw new Error(
            "WGPU Object must be associated to Device to call async method.",
          );
        }
        const cb = new Deno.UnsafeCallback(
          CreateComputePipelineAsyncCallback,
          (...args: U.CbParam<typeof CreateComputePipelineAsyncCallback>) => {
            data = [
              args[0] as CreatePipelineAsyncStatus,
              new ComputePipeline(args[1], this),
              args[2],
            ];
          },
        );
        lib.symbols.wgpuDeviceCreateComputePipelineAsync(
          this.pointer,
          descriptor instanceof ComputePipelineDescriptor
            ? descriptor.pointer
            : U.duckIsPointer(descriptor)
            ? descriptor
            : ComputePipelineDescriptor.from(descriptor).pointer,
          cb.pointer,
          null,
        );
        const id = setInterval(() => {
          if (lib.symbols.wgpuDevicePoll(device.pointer, 0, null)) {
            clearInterval(id);
            res(data!);
          }
        }, 10);
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuDeviceCreateComputePipelineAsync(
        this.pointer,
        descriptor instanceof ComputePipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : ComputePipelineDescriptor.from(descriptor).pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        CreateComputePipelineAsyncCallback,
        (...args: U.CbParam<typeof CreateComputePipelineAsyncCallback>) => {
          callback(...[
            args[0] as CreatePipelineAsyncStatus,
            new ComputePipeline(args[1], this),
            args[2],
          ]);
        },
      );
      lib.symbols.wgpuDeviceCreateComputePipelineAsync(
        this.pointer,
        descriptor instanceof ComputePipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : ComputePipelineDescriptor.from(descriptor).pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuDeviceCreateComputePipelineAsync(
        this.pointer,
        descriptor instanceof ComputePipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : ComputePipelineDescriptor.from(descriptor).pointer,
        callback,
        null,
      );
    }
  }

  createPipelineLayout(
    descriptor?:
      | PipelineLayoutDescriptor
      | null
      | ToPipelineLayoutDescriptor
      | Deno.PointerValue,
  ): PipelineLayout {
    const result = lib.symbols.wgpuDeviceCreatePipelineLayout(
      this.pointer,
      descriptor instanceof PipelineLayoutDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : PipelineLayoutDescriptor.from(descriptor).pointer,
    );
    return new PipelineLayout(result, this);
  }

  createQuerySet(
    descriptor?:
      | QuerySetDescriptor
      | null
      | ToQuerySetDescriptor
      | Deno.PointerValue,
  ): QuerySet {
    const result = lib.symbols.wgpuDeviceCreateQuerySet(
      this.pointer,
      descriptor instanceof QuerySetDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : QuerySetDescriptor.from(descriptor).pointer,
    );
    return new QuerySet(result, this);
  }

  createRenderBundleEncoder(
    descriptor?:
      | RenderBundleEncoderDescriptor
      | null
      | ToRenderBundleEncoderDescriptor
      | Deno.PointerValue,
  ): RenderBundleEncoder {
    const result = lib.symbols.wgpuDeviceCreateRenderBundleEncoder(
      this.pointer,
      descriptor instanceof RenderBundleEncoderDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : RenderBundleEncoderDescriptor.from(descriptor).pointer,
    );
    return new RenderBundleEncoder(result, this);
  }

  createRenderPipeline(
    descriptor?:
      | RenderPipelineDescriptor
      | null
      | ToRenderPipelineDescriptor
      | Deno.PointerValue,
  ): RenderPipeline {
    const result = lib.symbols.wgpuDeviceCreateRenderPipeline(
      this.pointer,
      descriptor instanceof RenderPipelineDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : RenderPipelineDescriptor.from(descriptor).pointer,
    );
    return new RenderPipeline(result, this);
  }

  createRenderPipelineAsync(
    descriptor?: RenderPipelineDescriptor | null,
  ): Promise<[CreatePipelineAsyncStatus, RenderPipeline, Deno.PointerValue]>;
  createRenderPipelineAsync(
    descriptor: RenderPipelineDescriptor | null,
    callback: (
      ...args: [CreatePipelineAsyncStatus, RenderPipeline, Deno.PointerValue]
    ) => void,
  ): Deno.UnsafeCallback<typeof CreateRenderPipelineAsyncCallback>;
  createRenderPipelineAsync(
    descriptor: RenderPipelineDescriptor | null,
    callback: Deno.UnsafeCallback<typeof CreateRenderPipelineAsyncCallback>,
  ): void;
  createRenderPipelineAsync(
    descriptor: RenderPipelineDescriptor | null,
    callback: Deno.PointerValue,
  ): void;
  createRenderPipelineAsync(
    descriptor: RenderPipelineDescriptor | null,
    callback?:
      | ((
        ...args: [CreatePipelineAsyncStatus, RenderPipeline, Deno.PointerValue]
      ) => void)
      | Deno.UnsafeCallback<typeof CreateRenderPipelineAsyncCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[CreatePipelineAsyncStatus, RenderPipeline, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof CreateRenderPipelineAsyncCallback> {
    if (callback == null) {
      return new Promise((res) => {
        let data: [
          CreatePipelineAsyncStatus,
          RenderPipeline,
          Deno.PointerValue,
        ];
        const device = this.findInFamily(Device);
        if (!device) {
          throw new Error(
            "WGPU Object must be associated to Device to call async method.",
          );
        }
        const cb = new Deno.UnsafeCallback(
          CreateRenderPipelineAsyncCallback,
          (...args: U.CbParam<typeof CreateRenderPipelineAsyncCallback>) => {
            data = [
              args[0] as CreatePipelineAsyncStatus,
              new RenderPipeline(args[1], this),
              args[2],
            ];
          },
        );
        lib.symbols.wgpuDeviceCreateRenderPipelineAsync(
          this.pointer,
          descriptor instanceof RenderPipelineDescriptor
            ? descriptor.pointer
            : U.duckIsPointer(descriptor)
            ? descriptor
            : RenderPipelineDescriptor.from(descriptor).pointer,
          cb.pointer,
          null,
        );
        const id = setInterval(() => {
          if (lib.symbols.wgpuDevicePoll(device.pointer, 0, null)) {
            clearInterval(id);
            res(data!);
          }
        }, 10);
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuDeviceCreateRenderPipelineAsync(
        this.pointer,
        descriptor instanceof RenderPipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : RenderPipelineDescriptor.from(descriptor).pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        CreateRenderPipelineAsyncCallback,
        (...args: U.CbParam<typeof CreateRenderPipelineAsyncCallback>) => {
          callback(...[
            args[0] as CreatePipelineAsyncStatus,
            new RenderPipeline(args[1], this),
            args[2],
          ]);
        },
      );
      lib.symbols.wgpuDeviceCreateRenderPipelineAsync(
        this.pointer,
        descriptor instanceof RenderPipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : RenderPipelineDescriptor.from(descriptor).pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuDeviceCreateRenderPipelineAsync(
        this.pointer,
        descriptor instanceof RenderPipelineDescriptor
          ? descriptor.pointer
          : U.duckIsPointer(descriptor)
          ? descriptor
          : RenderPipelineDescriptor.from(descriptor).pointer,
        callback,
        null,
      );
    }
  }

  createSampler(
    descriptor?:
      | SamplerDescriptor
      | null
      | ToSamplerDescriptor
      | Deno.PointerValue,
  ): Sampler {
    const result = lib.symbols.wgpuDeviceCreateSampler(
      this.pointer,
      descriptor instanceof SamplerDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : SamplerDescriptor.from(descriptor).pointer,
    );
    return new Sampler(result, this);
  }

  createShaderModule(
    descriptor?:
      | ShaderModuleDescriptor
      | null
      | ToShaderModuleDescriptor
      | Deno.PointerValue,
  ): ShaderModule {
    const result = lib.symbols.wgpuDeviceCreateShaderModule(
      this.pointer,
      descriptor instanceof ShaderModuleDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : ShaderModuleDescriptor.from(descriptor).pointer,
    );
    return new ShaderModule(result, this);
  }

  createSwapChain(
    surface: Surface,
    descriptor:
      | SwapChainDescriptor
      | null
      | ToSwapChainDescriptor
      | Deno.PointerValue,
  ): SwapChain {
    const result = lib.symbols.wgpuDeviceCreateSwapChain(
      this.pointer,
      surface.pointer,
      descriptor instanceof SwapChainDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : SwapChainDescriptor.from(descriptor).pointer,
    );
    return new SwapChain(result, this);
  }

  createTexture(
    descriptor?:
      | TextureDescriptor
      | null
      | ToTextureDescriptor
      | Deno.PointerValue,
  ): Texture {
    const result = lib.symbols.wgpuDeviceCreateTexture(
      this.pointer,
      descriptor instanceof TextureDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : TextureDescriptor.from(descriptor).pointer,
    );
    return new Texture(result, this);
  }

  destroy(): void {
    const result = lib.symbols.wgpuDeviceDestroy(this.pointer);
    return result;
  }

  enumerateFeatures(features: Deno.PointerValue): number | bigint {
    const result = lib.symbols.wgpuDeviceEnumerateFeatures(
      this.pointer,
      features,
    );
    return result;
  }

  getLimits(
    limits?: SupportedLimits | null | ToSupportedLimits | Deno.PointerValue,
  ): boolean {
    const result = lib.symbols.wgpuDeviceGetLimits(
      this.pointer,
      limits instanceof SupportedLimits
        ? limits.pointer
        : U.duckIsPointer(limits)
        ? limits
        : SupportedLimits.from(limits).pointer,
    );
    return result == 1;
  }

  getQueue(): Queue {
    const result = lib.symbols.wgpuDeviceGetQueue(this.pointer);
    return new Queue(result, this);
  }

  hasFeature(feature: FeatureName): boolean {
    const result = lib.symbols.wgpuDeviceHasFeature(this.pointer, feature);
    return result == 1;
  }

  popErrorScope(): Promise<[ErrorType, Deno.PointerValue]>;
  popErrorScope(
    callback: (...args: [ErrorType, Deno.PointerValue]) => void,
  ): Deno.UnsafeCallback<typeof ErrorCallback>;
  popErrorScope(callback: Deno.UnsafeCallback<typeof ErrorCallback>): void;
  popErrorScope(callback: Deno.PointerValue): void;
  popErrorScope(
    callback?:
      | ((...args: [ErrorType, Deno.PointerValue]) => void)
      | Deno.UnsafeCallback<typeof ErrorCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[ErrorType, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof ErrorCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          ErrorCallback,
          (...args: U.CbParam<typeof ErrorCallback>) => {
            res([args[0] as ErrorType, args[1]]);
          },
        );
        lib.symbols.wgpuDevicePopErrorScope(this.pointer, cb.pointer, null);
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuDevicePopErrorScope(this.pointer, callback.pointer, null);
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        ErrorCallback,
        (...args: U.CbParam<typeof ErrorCallback>) => {
          callback(...[args[0] as ErrorType, args[1]]);
        },
      );
      lib.symbols.wgpuDevicePopErrorScope(this.pointer, cb.pointer, null);
      return cb;
    } else {
      lib.symbols.wgpuDevicePopErrorScope(this.pointer, callback, null);
    }
  }

  pushErrorScope(filter: ErrorFilter): void {
    const result = lib.symbols.wgpuDevicePushErrorScope(this.pointer, filter);
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuDeviceSetLabel(this.pointer, label);
    return result;
  }

  setUncapturedErrorCallback(): Promise<[ErrorType, Deno.PointerValue]>;
  setUncapturedErrorCallback(
    callback: (...args: [ErrorType, Deno.PointerValue]) => void,
  ): Deno.UnsafeCallback<typeof ErrorCallback>;
  setUncapturedErrorCallback(
    callback: Deno.UnsafeCallback<typeof ErrorCallback>,
  ): void;
  setUncapturedErrorCallback(callback: Deno.PointerValue): void;
  setUncapturedErrorCallback(
    callback?:
      | ((...args: [ErrorType, Deno.PointerValue]) => void)
      | Deno.UnsafeCallback<typeof ErrorCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[ErrorType, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof ErrorCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          ErrorCallback,
          (...args: U.CbParam<typeof ErrorCallback>) => {
            res([args[0] as ErrorType, args[1]]);
          },
        );
        lib.symbols.wgpuDeviceSetUncapturedErrorCallback(
          this.pointer,
          cb.pointer,
          null,
        );
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuDeviceSetUncapturedErrorCallback(
        this.pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        ErrorCallback,
        (...args: U.CbParam<typeof ErrorCallback>) => {
          callback(...[args[0] as ErrorType, args[1]]);
        },
      );
      lib.symbols.wgpuDeviceSetUncapturedErrorCallback(
        this.pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuDeviceSetUncapturedErrorCallback(
        this.pointer,
        callback,
        null,
      );
    }
  }

  poll(
    wait: boolean,
    wrappedSubmissionIndex:
      | WrappedSubmissionIndex
      | null
      | ToWrappedSubmissionIndex
      | Deno.PointerValue,
  ): boolean {
    const result = lib.symbols.wgpuDevicePoll(
      this.pointer,
      wait ? 1 : 0,
      wrappedSubmissionIndex instanceof WrappedSubmissionIndex
        ? wrappedSubmissionIndex.pointer
        : U.duckIsPointer(wrappedSubmissionIndex)
        ? wrappedSubmissionIndex
        : WrappedSubmissionIndex.from(wrappedSubmissionIndex).pointer,
    );
    return result == 1;
  }
}

export class Instance extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuInstanceRelease]);
  }

  createSurface(
    descriptor?:
      | SurfaceDescriptor
      | null
      | ToSurfaceDescriptor
      | Deno.PointerValue,
  ): Surface {
    const result = lib.symbols.wgpuInstanceCreateSurface(
      this.pointer,
      descriptor instanceof SurfaceDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : SurfaceDescriptor.from(descriptor).pointer,
    );
    return new Surface(result, this);
  }

  processEvents(): void {
    const result = lib.symbols.wgpuInstanceProcessEvents(this.pointer);
    return result;
  }

  requestAdapter(
    options?: RequestAdapterOptions | null,
  ): Promise<[RequestAdapterStatus, Adapter, Deno.PointerValue]>;
  requestAdapter(
    options: RequestAdapterOptions | null,
    callback: (
      ...args: [RequestAdapterStatus, Adapter, Deno.PointerValue]
    ) => void,
  ): Deno.UnsafeCallback<typeof RequestAdapterCallback>;
  requestAdapter(
    options: RequestAdapterOptions | null,
    callback: Deno.UnsafeCallback<typeof RequestAdapterCallback>,
  ): void;
  requestAdapter(
    options: RequestAdapterOptions | null,
    callback: Deno.PointerValue,
  ): void;
  requestAdapter(
    options: RequestAdapterOptions | null,
    callback?:
      | ((...args: [RequestAdapterStatus, Adapter, Deno.PointerValue]) => void)
      | Deno.UnsafeCallback<typeof RequestAdapterCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[RequestAdapterStatus, Adapter, Deno.PointerValue]>
    | Deno.UnsafeCallback<typeof RequestAdapterCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          RequestAdapterCallback,
          (...args: U.CbParam<typeof RequestAdapterCallback>) => {
            res([
              args[0] as RequestAdapterStatus,
              new Adapter(args[1], this),
              args[2],
            ]);
          },
        );
        lib.symbols.wgpuInstanceRequestAdapter(
          this.pointer,
          options instanceof RequestAdapterOptions
            ? options.pointer
            : U.duckIsPointer(options)
            ? options
            : RequestAdapterOptions.from(options).pointer,
          cb.pointer,
          null,
        );
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuInstanceRequestAdapter(
        this.pointer,
        options instanceof RequestAdapterOptions
          ? options.pointer
          : U.duckIsPointer(options)
          ? options
          : RequestAdapterOptions.from(options).pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        RequestAdapterCallback,
        (...args: U.CbParam<typeof RequestAdapterCallback>) => {
          callback(...[
            args[0] as RequestAdapterStatus,
            new Adapter(args[1], this),
            args[2],
          ]);
        },
      );
      lib.symbols.wgpuInstanceRequestAdapter(
        this.pointer,
        options instanceof RequestAdapterOptions
          ? options.pointer
          : U.duckIsPointer(options)
          ? options
          : RequestAdapterOptions.from(options).pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuInstanceRequestAdapter(
        this.pointer,
        options instanceof RequestAdapterOptions
          ? options.pointer
          : U.duckIsPointer(options)
          ? options
          : RequestAdapterOptions.from(options).pointer,
        callback,
        null,
      );
    }
  }

  enumerateAdapters(
    options:
      | InstanceEnumerateAdapterOptions
      | null
      | ToInstanceEnumerateAdapterOptions
      | Deno.PointerValue,
    adapters: Deno.PointerValue,
  ): number | bigint {
    const result = lib.symbols.wgpuInstanceEnumerateAdapters(
      this.pointer,
      options instanceof InstanceEnumerateAdapterOptions
        ? options.pointer
        : U.duckIsPointer(options)
        ? options
        : InstanceEnumerateAdapterOptions.from(options).pointer,
      adapters,
    );
    return result;
  }
}

export class PipelineLayout extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuPipelineLayoutRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuPipelineLayoutSetLabel(this.pointer, label);
    return result;
  }
}

export class QuerySet extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuQuerySetRelease]);
  }

  destroy(): void {
    const result = lib.symbols.wgpuQuerySetDestroy(this.pointer);
    return result;
  }

  getCount(): number {
    const result = lib.symbols.wgpuQuerySetGetCount(this.pointer);
    return result;
  }

  getType(): QueryType {
    const result = lib.symbols.wgpuQuerySetGetType(this.pointer);
    return result as QueryType;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuQuerySetSetLabel(this.pointer, label);
    return result;
  }
}

export class Queue extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuQueueRelease]);
  }
  onSubmittedWorkDone(): Promise<[QueueWorkDoneStatus]>;
  onSubmittedWorkDone(
    callback: (...args: [QueueWorkDoneStatus]) => void,
  ): Deno.UnsafeCallback<typeof QueueWorkDoneCallback>;
  onSubmittedWorkDone(
    callback: Deno.UnsafeCallback<typeof QueueWorkDoneCallback>,
  ): void;
  onSubmittedWorkDone(callback: Deno.PointerValue): void;
  onSubmittedWorkDone(
    callback?:
      | ((...args: [QueueWorkDoneStatus]) => void)
      | Deno.UnsafeCallback<typeof QueueWorkDoneCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[QueueWorkDoneStatus]>
    | Deno.UnsafeCallback<typeof QueueWorkDoneCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          QueueWorkDoneCallback,
          (...args: U.CbParam<typeof QueueWorkDoneCallback>) => {
            res([args[0] as QueueWorkDoneStatus]);
          },
        );
        lib.symbols.wgpuQueueOnSubmittedWorkDone(
          this.pointer,
          cb.pointer,
          null,
        );
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuQueueOnSubmittedWorkDone(
        this.pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        QueueWorkDoneCallback,
        (...args: U.CbParam<typeof QueueWorkDoneCallback>) => {
          callback(...[args[0] as QueueWorkDoneStatus]);
        },
      );
      lib.symbols.wgpuQueueOnSubmittedWorkDone(this.pointer, cb.pointer, null);
      return cb;
    } else {
      lib.symbols.wgpuQueueOnSubmittedWorkDone(this.pointer, callback, null);
    }
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuQueueSetLabel(this.pointer, label);
    return result;
  }

  submit(commandCount: number | bigint, commands: Deno.PointerValue): void {
    const result = lib.symbols.wgpuQueueSubmit(
      this.pointer,
      commandCount,
      commands,
    );
    return result;
  }

  writeBuffer(
    buffer: Buffer,
    bufferOffset: number | bigint,
    data: Deno.PointerValue,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuQueueWriteBuffer(
      this.pointer,
      buffer.pointer,
      bufferOffset,
      data,
      size,
    );
    return result;
  }

  writeTexture(
    destination:
      | ImageCopyTexture
      | null
      | ToImageCopyTexture
      | Deno.PointerValue,
    data: Deno.PointerValue,
    dataSize: number | bigint,
    dataLayout:
      | TextureDataLayout
      | null
      | ToTextureDataLayout
      | Deno.PointerValue,
    writeSize: Extent3D | null | ToExtent3D | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuQueueWriteTexture(
      this.pointer,
      destination instanceof ImageCopyTexture
        ? destination.pointer
        : U.duckIsPointer(destination)
        ? destination
        : ImageCopyTexture.from(destination).pointer,
      data,
      dataSize,
      dataLayout instanceof TextureDataLayout
        ? dataLayout.pointer
        : U.duckIsPointer(dataLayout)
        ? dataLayout
        : TextureDataLayout.from(dataLayout).pointer,
      writeSize instanceof Extent3D
        ? writeSize.pointer
        : U.duckIsPointer(writeSize)
        ? writeSize
        : Extent3D.from(writeSize).pointer,
    );
    return result;
  }

  submitForIndex(
    commandCount: number | bigint,
    commands: Deno.PointerValue,
  ): number | bigint {
    const result = lib.symbols.wgpuQueueSubmitForIndex(
      this.pointer,
      commandCount,
      commands,
    );
    return result;
  }
}

export class RenderBundle extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuRenderBundleRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderBundleSetLabel(this.pointer, label);
    return result;
  }
}

export class RenderBundleEncoder extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [
      pointer,
      lib.symbols.wgpuRenderBundleEncoderRelease,
    ]);
  }

  draw(
    vertexCount: number,
    instanceCount: number,
    firstVertex: number,
    firstInstance: number,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderDraw(
      this.pointer,
      vertexCount,
      instanceCount,
      firstVertex,
      firstInstance,
    );
    return result;
  }

  drawIndexed(
    indexCount: number,
    instanceCount: number,
    firstIndex: number,
    baseVertex: number,
    firstInstance: number,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderDrawIndexed(
      this.pointer,
      indexCount,
      instanceCount,
      firstIndex,
      baseVertex,
      firstInstance,
    );
    return result;
  }

  drawIndexedIndirect(
    indirectBuffer: Buffer,
    indirectOffset: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderDrawIndexedIndirect(
      this.pointer,
      indirectBuffer.pointer,
      indirectOffset,
    );
    return result;
  }

  drawIndirect(indirectBuffer: Buffer, indirectOffset: number | bigint): void {
    const result = lib.symbols.wgpuRenderBundleEncoderDrawIndirect(
      this.pointer,
      indirectBuffer.pointer,
      indirectOffset,
    );
    return result;
  }

  finish(
    descriptor?:
      | RenderBundleDescriptor
      | null
      | ToRenderBundleDescriptor
      | Deno.PointerValue,
  ): RenderBundle {
    const result = lib.symbols.wgpuRenderBundleEncoderFinish(
      this.pointer,
      descriptor instanceof RenderBundleDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : RenderBundleDescriptor.from(descriptor).pointer,
    );
    return new RenderBundle(result, this);
  }

  insertDebugMarker(markerLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderBundleEncoderInsertDebugMarker(
      this.pointer,
      markerLabel,
    );
    return result;
  }

  popDebugGroup(): void {
    const result = lib.symbols.wgpuRenderBundleEncoderPopDebugGroup(
      this.pointer,
    );
    return result;
  }

  pushDebugGroup(groupLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderBundleEncoderPushDebugGroup(
      this.pointer,
      groupLabel,
    );
    return result;
  }

  setBindGroup(
    groupIndex: number,
    group: BindGroup,
    dynamicOffsetCount: number | bigint,
    dynamicOffsets: Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderSetBindGroup(
      this.pointer,
      groupIndex,
      group.pointer,
      dynamicOffsetCount,
      dynamicOffsets,
    );
    return result;
  }

  setIndexBuffer(
    buffer: Buffer,
    format: IndexFormat,
    offset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderSetIndexBuffer(
      this.pointer,
      buffer.pointer,
      format,
      offset,
      size,
    );
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderBundleEncoderSetLabel(
      this.pointer,
      label,
    );
    return result;
  }

  setPipeline(pipeline: RenderPipeline): void {
    const result = lib.symbols.wgpuRenderBundleEncoderSetPipeline(
      this.pointer,
      pipeline.pointer,
    );
    return result;
  }

  setVertexBuffer(
    slot: number,
    buffer: Buffer,
    offset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderBundleEncoderSetVertexBuffer(
      this.pointer,
      slot,
      buffer.pointer,
      offset,
      size,
    );
    return result;
  }
}

export class RenderPassEncoder extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [
      pointer,
      lib.symbols.wgpuRenderPassEncoderRelease,
    ]);
  }

  beginOcclusionQuery(queryIndex: number): void {
    const result = lib.symbols.wgpuRenderPassEncoderBeginOcclusionQuery(
      this.pointer,
      queryIndex,
    );
    return result;
  }

  beginPipelineStatisticsQuery(querySet: QuerySet, queryIndex: number): void {
    const result = lib.symbols
      .wgpuRenderPassEncoderBeginPipelineStatisticsQuery(
        this.pointer,
        querySet.pointer,
        queryIndex,
      );
    return result;
  }

  draw(
    vertexCount: number,
    instanceCount: number,
    firstVertex: number,
    firstInstance: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderDraw(
      this.pointer,
      vertexCount,
      instanceCount,
      firstVertex,
      firstInstance,
    );
    return result;
  }

  drawIndexed(
    indexCount: number,
    instanceCount: number,
    firstIndex: number,
    baseVertex: number,
    firstInstance: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderDrawIndexed(
      this.pointer,
      indexCount,
      instanceCount,
      firstIndex,
      baseVertex,
      firstInstance,
    );
    return result;
  }

  drawIndexedIndirect(
    indirectBuffer: Buffer,
    indirectOffset: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderDrawIndexedIndirect(
      this.pointer,
      indirectBuffer.pointer,
      indirectOffset,
    );
    return result;
  }

  drawIndirect(indirectBuffer: Buffer, indirectOffset: number | bigint): void {
    const result = lib.symbols.wgpuRenderPassEncoderDrawIndirect(
      this.pointer,
      indirectBuffer.pointer,
      indirectOffset,
    );
    return result;
  }

  end(): void {
    const result = lib.symbols.wgpuRenderPassEncoderEnd(this.pointer);
    return result;
  }

  endOcclusionQuery(): void {
    const result = lib.symbols.wgpuRenderPassEncoderEndOcclusionQuery(
      this.pointer,
    );
    return result;
  }

  endPipelineStatisticsQuery(): void {
    const result = lib.symbols.wgpuRenderPassEncoderEndPipelineStatisticsQuery(
      this.pointer,
    );
    return result;
  }

  executeBundles(
    bundleCount: number | bigint,
    bundles: Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderExecuteBundles(
      this.pointer,
      bundleCount,
      bundles,
    );
    return result;
  }

  insertDebugMarker(markerLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderPassEncoderInsertDebugMarker(
      this.pointer,
      markerLabel,
    );
    return result;
  }

  popDebugGroup(): void {
    const result = lib.symbols.wgpuRenderPassEncoderPopDebugGroup(this.pointer);
    return result;
  }

  pushDebugGroup(groupLabel: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderPassEncoderPushDebugGroup(
      this.pointer,
      groupLabel,
    );
    return result;
  }

  setBindGroup(
    groupIndex: number,
    group: BindGroup,
    dynamicOffsetCount: number | bigint,
    dynamicOffsets: Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetBindGroup(
      this.pointer,
      groupIndex,
      group.pointer,
      dynamicOffsetCount,
      dynamicOffsets,
    );
    return result;
  }

  setBlendConstant(color?: Color | null | ToColor | Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetBlendConstant(
      this.pointer,
      color instanceof Color
        ? color.pointer
        : U.duckIsPointer(color)
        ? color
        : Color.from(color).pointer,
    );
    return result;
  }

  setIndexBuffer(
    buffer: Buffer,
    format: IndexFormat,
    offset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetIndexBuffer(
      this.pointer,
      buffer.pointer,
      format,
      offset,
      size,
    );
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetLabel(
      this.pointer,
      label,
    );
    return result;
  }

  setPipeline(pipeline: RenderPipeline): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetPipeline(
      this.pointer,
      pipeline.pointer,
    );
    return result;
  }

  setScissorRect(x: number, y: number, width: number, height: number): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetScissorRect(
      this.pointer,
      x,
      y,
      width,
      height,
    );
    return result;
  }

  setStencilReference(reference: number): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetStencilReference(
      this.pointer,
      reference,
    );
    return result;
  }

  setVertexBuffer(
    slot: number,
    buffer: Buffer,
    offset: number | bigint,
    size: number | bigint,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetVertexBuffer(
      this.pointer,
      slot,
      buffer.pointer,
      offset,
      size,
    );
    return result;
  }

  setViewport(
    x: number,
    y: number,
    width: number,
    height: number,
    minDepth: number,
    maxDepth: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetViewport(
      this.pointer,
      x,
      y,
      width,
      height,
      minDepth,
      maxDepth,
    );
    return result;
  }

  setPushConstants(
    stages: number,
    offset: number,
    sizeBytes: number,
    data: Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderSetPushConstants(
      this.pointer,
      stages,
      offset,
      sizeBytes,
      data,
    );
    return result;
  }

  multiDrawIndirect(
    buffer: Buffer,
    offset: number | bigint,
    count: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderMultiDrawIndirect(
      this.pointer,
      buffer.pointer,
      offset,
      count,
    );
    return result;
  }

  multiDrawIndexedIndirect(
    buffer: Buffer,
    offset: number | bigint,
    count: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderMultiDrawIndexedIndirect(
      this.pointer,
      buffer.pointer,
      offset,
      count,
    );
    return result;
  }

  multiDrawIndirectCount(
    buffer: Buffer,
    offset: number | bigint,
    count_buffer: Buffer,
    count_buffer_offset: number | bigint,
    max_count: number,
  ): void {
    const result = lib.symbols.wgpuRenderPassEncoderMultiDrawIndirectCount(
      this.pointer,
      buffer.pointer,
      offset,
      count_buffer.pointer,
      count_buffer_offset,
      max_count,
    );
    return result;
  }

  multiDrawIndexedIndirectCount(
    buffer: Buffer,
    offset: number | bigint,
    count_buffer: Buffer,
    count_buffer_offset: number | bigint,
    max_count: number,
  ): void {
    const result = lib.symbols
      .wgpuRenderPassEncoderMultiDrawIndexedIndirectCount(
        this.pointer,
        buffer.pointer,
        offset,
        count_buffer.pointer,
        count_buffer_offset,
        max_count,
      );
    return result;
  }
}

export class RenderPipeline extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuRenderPipelineRelease]);
  }

  getBindGroupLayout(groupIndex: number): BindGroupLayout {
    const result = lib.symbols.wgpuRenderPipelineGetBindGroupLayout(
      this.pointer,
      groupIndex,
    );
    return new BindGroupLayout(result, this);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuRenderPipelineSetLabel(this.pointer, label);
    return result;
  }
}

export class Sampler extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuSamplerRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuSamplerSetLabel(this.pointer, label);
    return result;
  }
}

export class ShaderModule extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuShaderModuleRelease]);
  }
  getCompilationInfo(): Promise<
    [CompilationInfoRequestStatus, CompilationInfo | null]
  >;
  getCompilationInfo(
    callback: (
      ...args: [CompilationInfoRequestStatus, CompilationInfo | null]
    ) => void,
  ): Deno.UnsafeCallback<typeof CompilationInfoCallback>;
  getCompilationInfo(
    callback: Deno.UnsafeCallback<typeof CompilationInfoCallback>,
  ): void;
  getCompilationInfo(callback: Deno.PointerValue): void;
  getCompilationInfo(
    callback?:
      | ((
        ...args: [CompilationInfoRequestStatus, CompilationInfo | null]
      ) => void)
      | Deno.UnsafeCallback<typeof CompilationInfoCallback>
      | Deno.PointerValue,
  ):
    | void
    | Promise<[CompilationInfoRequestStatus, CompilationInfo | null]>
    | Deno.UnsafeCallback<typeof CompilationInfoCallback> {
    if (callback == null) {
      return new Promise((res) => {
        const cb = new Deno.UnsafeCallback(
          CompilationInfoCallback,
          (...args: U.CbParam<typeof CompilationInfoCallback>) => {
            res([
              args[0] as CompilationInfoRequestStatus,
              args[1] === null ? null : new CompilationInfo(args[1]),
            ]);
          },
        );
        lib.symbols.wgpuShaderModuleGetCompilationInfo(
          this.pointer,
          cb.pointer,
          null,
        );
      });
    } else if (callback instanceof Deno.UnsafeCallback) {
      lib.symbols.wgpuShaderModuleGetCompilationInfo(
        this.pointer,
        callback.pointer,
        null,
      );
    } else if (callback instanceof Function) {
      const cb = new Deno.UnsafeCallback(
        CompilationInfoCallback,
        (...args: U.CbParam<typeof CompilationInfoCallback>) => {
          callback(...[
            args[0] as CompilationInfoRequestStatus,
            args[1] === null ? null : new CompilationInfo(args[1]),
          ]);
        },
      );
      lib.symbols.wgpuShaderModuleGetCompilationInfo(
        this.pointer,
        cb.pointer,
        null,
      );
      return cb;
    } else {
      lib.symbols.wgpuShaderModuleGetCompilationInfo(
        this.pointer,
        callback,
        null,
      );
    }
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuShaderModuleSetLabel(this.pointer, label);
    return result;
  }
}

export class Surface extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuSurfaceRelease]);
  }

  getPreferredFormat(adapter: Adapter): TextureFormat {
    const result = lib.symbols.wgpuSurfaceGetPreferredFormat(
      this.pointer,
      adapter.pointer,
    );
    return result as TextureFormat;
  }

  getCapabilities(
    adapter: Adapter,
    capabilities:
      | SurfaceCapabilities
      | null
      | ToSurfaceCapabilities
      | Deno.PointerValue,
  ): void {
    const result = lib.symbols.wgpuSurfaceGetCapabilities(
      this.pointer,
      adapter.pointer,
      capabilities instanceof SurfaceCapabilities
        ? capabilities.pointer
        : U.duckIsPointer(capabilities)
        ? capabilities
        : SurfaceCapabilities.from(capabilities).pointer,
    );
    return result;
  }
}

export class SwapChain extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuSwapChainRelease]);
  }

  getCurrentTextureView(): TextureView {
    const result = lib.symbols.wgpuSwapChainGetCurrentTextureView(this.pointer);
    return new TextureView(result, this);
  }

  present(): void {
    const result = lib.symbols.wgpuSwapChainPresent(this.pointer);
    return result;
  }
}

export class Texture extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuTextureRelease]);
  }

  createView(
    descriptor?:
      | TextureViewDescriptor
      | null
      | ToTextureViewDescriptor
      | Deno.PointerValue,
  ): TextureView {
    const result = lib.symbols.wgpuTextureCreateView(
      this.pointer,
      descriptor instanceof TextureViewDescriptor
        ? descriptor.pointer
        : U.duckIsPointer(descriptor)
        ? descriptor
        : TextureViewDescriptor.from(descriptor).pointer,
    );
    return new TextureView(result, this);
  }

  destroy(): void {
    const result = lib.symbols.wgpuTextureDestroy(this.pointer);
    return result;
  }

  getDepthOrArrayLayers(): number {
    const result = lib.symbols.wgpuTextureGetDepthOrArrayLayers(this.pointer);
    return result;
  }

  getDimension(): TextureDimension {
    const result = lib.symbols.wgpuTextureGetDimension(this.pointer);
    return result as TextureDimension;
  }

  getFormat(): TextureFormat {
    const result = lib.symbols.wgpuTextureGetFormat(this.pointer);
    return result as TextureFormat;
  }

  getHeight(): number {
    const result = lib.symbols.wgpuTextureGetHeight(this.pointer);
    return result;
  }

  getMipLevelCount(): number {
    const result = lib.symbols.wgpuTextureGetMipLevelCount(this.pointer);
    return result;
  }

  getSampleCount(): number {
    const result = lib.symbols.wgpuTextureGetSampleCount(this.pointer);
    return result;
  }

  getUsage(): number {
    const result = lib.symbols.wgpuTextureGetUsage(this.pointer);
    return result;
  }

  getWidth(): number {
    const result = lib.symbols.wgpuTextureGetWidth(this.pointer);
    return result;
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuTextureSetLabel(this.pointer, label);
    return result;
  }
}

export class TextureView extends U.ClassBase {
  constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
    super(pointer, parent);
    U.registry.register(this, [pointer, lib.symbols.wgpuTextureViewRelease]);
  }

  setLabel(label: Deno.PointerValue): void {
    const result = lib.symbols.wgpuTextureViewSetLabel(this.pointer, label);
    return result;
  }
}
