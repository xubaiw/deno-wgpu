/**
 * @file This mod extract information from `vendor/*.h` and generate js binding to `src/gen`.
 *
 * The generator works in 2 tier:
 * - Tier 1: Basic symbol export (Deno.dlopen)
 * - Tier 2: Ergonomic wrapper around tier 1 (Enum, Struct, Class, Promise, etc...)
 *
 * Functions in this file generally follows the following naming convention:
 * - `writeXXX`: Dumpers, who call generators and actually write generated string to file. (Only writeTier1 and writeTier2)
 * - `generateXXX`: Generate content text
 * - `extractXXX`: extract infotmation that is used by generators
 * - `translateXXX`: translate libclang type
 */

import { ensureDir } from "https://deno.land/std@0.197.0/fs/ensure_dir.ts";
import { fromFileUrl } from "https://deno.land/std@0.197.0/path/mod.ts";
import camelCase from "https://deno.land/x/case@2.1.1/camelCase.ts";
import { join } from "https://deno.land/std@0.197.0/path/mod.ts";
import {
  CXChildVisitResult,
  CXCursorKind,
  CXIndex,
  CXTranslationUnit,
} from "https://deno.land/x/libclang@1.0.0-beta.8/mod.ts";
import { dedent } from "npm:@qnighy/dedent";

/** Mutable shared context to easily access information */
type Ctx = {
  tu: CXTranslationUnit;
  dir: string;
  symbols: Record<string, SymbolSpec>;
  callbacks: Record<string, CallbackSpec>;
  enums: Record<string, Record<string, unknown>>;
  structs: Record<string, StructSpec>;
  functions: Record<string, FunctionSpec>;
  classes: Record<string, Record<string, FunctionSpec>>;
};

type StructSpec = {
  size: number;
  fields: Record<string, FieldSpec>;
};

type FieldSpec = {
  offset: number;
  size: number;
  kind: string;
  type: string;
};

/** Do not use Deno.NativeType make life easier */
type SymbolSpec = {
  parameters: string[];
  result: string;
};

type FunctionSpec = {
  parameters: NamedTypeSpec[];
  result: TypeSpec;
};

type TypeSpec = {
  kind: string;
  type: string;
};

type NamedTypeSpec = TypeSpec & { name: string };

type CallbackSpec = {
  parameters: TypeSpec[];
  result: TypeSpec;
};

// Run main!
import.meta.main && await main();

/** Entry point for the whole generator */
async function main() {
  const ctx = extractCtx();
  await ensureDir(ctx.dir);
  await writeTier1(ctx);
  await writeTier2(ctx);
}

/** Write tier 1 binding (dlopen symbols). */
async function writeTier1(ctx: Ctx) {
  const { dir, symbols } = ctx;
  // generate file content
  const text = dedent`
    /** 
     * @file This file is generated by "../tool/gen.ts#writeTier1" and should not be modified manually.
     */
    import { prepare } from "./prepare.ts";
    const libPath = await prepare();
    export default Deno.dlopen(libPath, ${JSON.stringify(symbols)});
  `;
  // write
  await Deno.writeTextFile(join(dir, `tier1.ts`), text);
}

/** Extract all information and create  */
function extractCtx(): Ctx {
  const header = fromFileUrl(import.meta.resolve("../vendor/wgpu.h"));
  const dir = fromFileUrl(import.meta.resolve("../src/"));
  const tu = new CXIndex().parseTranslationUnit(header);
  // prepare ctx
  const ctx: Ctx = {
    tu,
    dir,
    symbols: {},
    callbacks: {},
    enums: {},
    structs: {},
    classes: {},
    functions: {},
  };
  // actual extracts
  extractSymbols(ctx);
  extractCallbacks(ctx);
  extractEnums(ctx);
  extractStructs(ctx);
  extractErgos(ctx);
  return ctx;
}

function extractEnums({ tu, enums }: Ctx) {
  // visit
  tu.getCursor().visitChildren((cursor) => {
    // only handle enums
    if (cursor.kind == CXCursorKind.CXCursor_EnumDecl) {
      // do not use enum name to merge implementation-native enums
      // visit sub constants
      cursor.visitChildren((cursor) => {
        // handle constants
        if (cursor.kind == CXCursorKind.CXCursor_EnumConstantDecl) {
          let [name, key] = nofix(cursor.getSpelling()).split("_");
          // special mapping of NativeFeature => FeatureName
          if (name == "NativeFeature") name = "FeatureName";
          // `Force32` is used to force enum to be uint32_t, so just skip it
          if (key == "Force32") return CXChildVisitResult.CXChildVisit_Continue;
          if (enums[name] == null) enums[name] = {};
          const value = cursor.getEnumConstantDeclarationUnsignedValue();
          enums[name][key] = value;
        }
        return CXChildVisitResult.CXChildVisit_Continue;
      });
    }
    return CXChildVisitResult.CXChildVisit_Continue;
  });
}

/** Extract callback from typedefs */
function extractCallbacks({ tu, callbacks }: Ctx) {
  tu.getCursor().visitChildren((cursor) => {
    if (cursor.kind == CXCursorKind.CXCursor_TypedefDecl) {
      // "name"
      const name = cursor.getSpelling();
      // if name contains Callback then it's callback
      if (name.match(/Callback/)) {
        // pointee is the actual function type
        const pointee = cursor.getTypedefDeclarationOfUnderlyingType()!
          .getPointeeType()!;
        // "result"
        const rKind = pointee.getResultType()!.getCanonicalType()
          .getKindSpelling();
        const rType = pointee.getResultType()!.getSpelling();
        const result = { kind: rKind, type: rType };
        // "parameters"
        const parameters = [];
        for (let i = 0; i < pointee.getNumberOfArgumentTypes(); i++) {
          const pKind = pointee.getArgumentType(i)!.getCanonicalType()
            .getKindSpelling();
          const pType = pointee.getArgumentType(i)!.getSpelling();
          const p = { kind: pKind, type: pType };
          parameters.push(p);
        }
        callbacks[name] = { result, parameters };
      }
    }
    return CXChildVisitResult.CXChildVisit_Recurse;
  });
}

function extractSymbols({ tu, symbols }: Ctx) {
  // visit
  tu.getCursor().visitChildren((cursor) => {
    // handle only function decl
    if (cursor.kind == CXCursorKind.CXCursor_FunctionDecl) {
      // "name"
      const name = cursor.getSpelling();
      // "result"
      const resultKind = cursor.getResultType()!.getCanonicalType()
        .getKindSpelling();
      const result = translateKindToDenoNative(resultKind);
      // "parameters"
      const parameters = [];
      for (let i = 0; i < cursor.getNumberOfArguments(); i++) {
        const pCursor = cursor.getArgument(i)!;
        const pKind = pCursor.getType()!.getCanonicalType().getKindSpelling();
        const type = translateKindToDenoNative(pKind);
        parameters.push(type);
      }
      symbols[name] = { result, parameters };
    }
    return CXChildVisitResult.CXChildVisit_Continue;
  });
  return symbols;
}

function translateKindToDenoNative(kind: string) {
  if (kind == "Pointer") return "pointer";
  if (kind == "ULong") return "u64";
  if (kind == "Bool") return "u8";
  if (kind == "Void") return "void";
  if (kind == "Enum") return "u32";
  if (kind == "ULongLong") return "u64";
  if (kind == "UInt") return "u32";
  if (kind == "Int") return "i32";
  if (kind == "Float") return "f32";
  throw new Error(`kind ${kind} not implemented`);
}

async function writeTier2(ctx: Ctx) {
  const { dir } = ctx;
  const enums = generateEnums(ctx);
  const structs = generateStructs(ctx);
  const callbacks = generateCallbacks(ctx);
  const ergos = generateErgos(ctx);
  const text = dedent`
    /** 
     * @file This file is generated by "../tool/gen.ts#writeTier2" and should not be modified manually.
     */
    import * as U from "./util.ts";
    import lib from "./tier1.ts";

    ${enums}
    ${structs}
    ${callbacks}
    ${ergos}
  `;
  await Deno.writeTextFile(join(dir, `tier2.ts`), text);
}

/** Remove the WGPU/wgpu prefix. */
function nofix(name: string): string {
  if (name.match(/^w/)) {
    return name.replace(/^wgpu/, "");
  } else return name.replace(/^WGPU/, "");
}

/** Insert separator to array of string. */
function sep(s: string) {
  const nn = <T>(x: T): x is NonNullable<T> => x !== null;
  return (...xs: (string | null | (string | null)[])[]): string =>
    xs.filter(nn).map((x) => typeof x == "string" ? x : x.filter(nn).join(s))
      .join(s);
}

/** Map key of object. */
function km<T>(
  xs: Record<string, unknown>,
  fn: (x: string, i: number) => T,
): T[] {
  return Object.keys(xs).map(fn);
}

function generateEnums({ enums }: Ctx) {
  // generate text content
  return sep("\n")(km(enums, (name) => {
    const body = sep(",")(km(enums[name], (key) => {
      const k = key.match(/^\d/) ? `_${key}` : key;
      const v = enums[name][key];
      return `${k} = ${v}`;
    }));
    return `export enum ${nofix(name)} { ${body} }`;
  }));
}

function extractStructs({ tu, structs }: Ctx) {
  // visit
  tu.getCursor().visitChildren((cursor) => {
    // only handle struct decl
    if (cursor.kind == CXCursorKind.CXCursor_StructDecl) {
      const name = cursor.getSpelling();
      const size = cursor.getType()!.getSizeOf();
      const fields: Record<string, FieldSpec> = {};
      cursor.visitChildren((cursor) => {
        if (cursor.kind == CXCursorKind.CXCursor_FieldDecl) {
          const name = cursor.getSpelling();
          const offset = cursor.getOffsetOfField() / 8;
          const kind = cursor.getType()!.getCanonicalType().getKindSpelling();
          const type = cursor.getType()!.getSpelling();
          const size = cursor.getType()!.getSizeOf();
          fields[name] = { offset, kind, type, size };
        }
        return CXChildVisitResult.CXChildVisit_Continue;
      });
      structs[name] = { size, fields };
    }
    return CXChildVisitResult.CXChildVisit_Recurse;
  });
}

function generateStructs(ctx: Ctx) {
  const { structs } = ctx;
  const structdecl = sep("\n")(
    km(structs, (sname) => generateStruct(ctx, sname)),
  );
  const text = dedent`
    ${structdecl}
  `;
  // actual write
  return text;
}

function generateStruct(ctx: Ctx, name: string) {
  const spec = ctx.structs[name];
  const size = spec.size;
  if (size < 0) return "";
  const properties = sep("\n\n")(
    km(spec.fields, (fname) => generateProperty(ctx, name, fname)),
  );
  const to = generateStructTo(ctx, name);
  const from = generateStructFrom(ctx, name);
  return dedent`
    ${to}
    export class ${nofix(name)} extends U.StructBase {
      dataview: DataView;
      constructor(dataviewOrPtr?: DataView | NonNullable<Deno.PointerValue>) {
        super();
        if (dataviewOrPtr == null) {
          this.dataview = new DataView(new ArrayBuffer(${size}));
        } else {
          if (dataviewOrPtr instanceof DataView) {
            this.dataview = dataviewOrPtr;
          } else {
            this.dataview = new DataView(new Deno.UnsafePointerView(dataviewOrPtr).getArrayBuffer(${size}))
          }
        }
      }
      ${properties}
      ${from}
    }
  `;
}

function generateStructTo(ctx: Ctx, name: string) {
  const fields = ctx.structs[name].fields;
  const body = sep(";")(
    km(
      fields,
      (fname) => `${fname}?: ${generateStructSetterType(ctx, name, fname)}`,
    ),
  );
  return dedent`
    export type To${nofix(name)} = undefined | {
      ${body}
    };
  `;
}

function generateProperty(...args: [Ctx, string, string]) {
  // FIXME: use property field
  const getter = generateStructGetter(...args);
  const setter = generateStructSetter(...args);
  return dedent`
    ${getter}
    ${setter}
  `;
}

function generateStructGetter(ctx: Ctx, sname: string, fname: string) {
  const type = genStructGetterType(ctx, sname, fname);
  const result = genStructGetterResult(ctx, sname, fname);
  return dedent`
    get ${fname}(): ${type} {
      return ${result};
    }
  `;
}

function generateStructSetter(ctx: Ctx, sname: string, fname: string) {
  const type = generateStructSetterType(ctx, sname, fname);
  const result = generateStructSetterResult(ctx, sname, fname);
  return `
    set ${fname}(value: ${type}) {
      ${result};
    }
  `;
}

function generateStructFrom(ctx: Ctx, name: string): string {
  const fields = ctx.structs[name].fields;
  const setters = (inner: string) =>
    sep(";")(
      km(
        fields,
        (fname) =>
          `if (plain.${fname} !== undefined) ${inner}.${fname} = plain.${fname}`,
      ),
    );
  return dedent`
    static from(plain: To${nofix(name)}) {
      const struct = new ${nofix(name)};
      if (plain === undefined) return struct;
      ${setters("struct")}
      return struct;
    }
    set(plain: To${nofix(name)}) {
      const struct = this;
      if (plain === undefined) return struct;
      ${setters("this")}
    }
  `;
}

function genStructGetterType(ctx: Ctx, name: string, fname: string) {
  const { kind, type } = ctx.structs[name].fields[fname];
  if (kind == "Record") return nofix(type!);
  if (kind == "Pointer") return "Deno.PointerValue";
  if (kind == "Enum") return `${nofix(type!)}`;
  if (kind == "UInt") return "number";
  if (kind == "ULongLong") return "bigint";
  if (kind == "Bool") return "boolean";
  if (kind == "Double") return "number";
  if (kind == "ULong") return "bigint";
  if (kind == "Float") return "number";
  if (kind == "UShort") return "number";
  if (kind == "Int") return "number";
  throw new Error(
    `getter type: kind ${kind} in ${name}.${fname} not implemented`,
  );
}

function genStructGetterResult(ctx: Ctx, name: string, fname: string) {
  const { offset, kind, type, size } = ctx.structs[name].fields[fname];
  if (kind == "Record") {
    return `new ${
      nofix(type!)
    }(new DataView(this.dataview.buffer, this.dataview.byteOffset + ${offset}, ${size}))`;
  }
  if (kind == "Pointer") {
    return `Deno.UnsafePointer.create(this.dataview.getBigUint64(${offset}, U.LE))`;
  }
  if (kind == "Enum") {
    return `this.dataview.getUint32(${offset}, U.LE) as ${nofix(type!)}`;
  }
  if (kind == "UInt") return `this.dataview.getUint32(${offset}, U.LE)`;
  if (kind == "ULongLong") return `this.dataview.getBigUint64(${offset}, U.LE)`;
  if (kind == "Bool") return `this.dataview.getUint8(${offset}) == 1`;
  if (kind == "Double") return `this.dataview.getFloat64(${offset}, U.LE)`;
  if (kind == "ULong") return `this.dataview.getBigUint64(${offset}, U.LE)`;
  if (kind == "Float") return `this.dataview.getFloat32(${offset}, U.LE)`;
  if (kind == "UShort") return `this.dataview.getUint16(${offset}, U.LE)`;
  if (kind == "Int") return `this.dataview.getInt32(${offset}, U.LE)`;
  throw new Error(
    `getter result: kind ${kind} in ${name}.${fname} not implemented`,
  );
}

function generateStructSetterResult(ctx: Ctx, name: string, fname: string) {
  const { offset, kind, size, type } = ctx.structs[name].fields[fname];
  if (kind == "Record") {
    return `
      if (value instanceof ${nofix(type)}) {
        const tv = this.dataview;
        const vv = value.dataview;
        new Uint8Array(tv.buffer, tv.byteOffset, ${size}).set(new Uint8Array(vv.buffer, vv.byteOffset, vv.byteLength))
      } else {
        this.${fname}.set(value);
      }
    `;
  }
  if (kind == "Pointer") {
    return `this.dataview.setBigUint64(${offset}, BigInt(Deno.UnsafePointer.value(value)), U.LE);`;
  }
  if (kind == "Enum") {
    return `this.dataview.setUint32(${offset}, value, U.LE)`;
  }
  if (kind == "UInt") return `this.dataview.setUint32(${offset}, value, U.LE)`;
  if (kind == "ULongLong") {
    return `this.dataview.setBigUint64(${offset}, BigInt(value), U.LE)`;
  }
  if (kind == "Bool") return `this.dataview.setUint8(${offset}, value ? 1 : 0)`;
  if (kind == "Double") {
    return `this.dataview.setFloat64(${offset}, value, U.LE)`;
  }
  if (kind == "ULong") {
    return `this.dataview.setBigUint64(${offset}, BigInt(value), U.LE)`;
  }
  if (kind == "Float") {
    return `this.dataview.setFloat32(${offset}, value, U.LE)`;
  }
  if (kind == "UShort") {
    return `this.dataview.setUint16(${offset}, value, U.LE)`;
  }
  if (kind == "Int") return `this.dataview.setInt32(${offset}, value, U.LE)`;
  throw new Error(
    `setter result: kind ${kind} in ${name}.${fname} not implemented`,
  );
}

function generateStructSetterType(ctx: Ctx, name: string, fname: string) {
  const { kind, type } = ctx.structs[name].fields[fname];
  if (kind == "Record") return `${nofix(type)} | To${nofix(type)}`;
  if (kind == "Pointer") return "Deno.PointerValue";
  if (kind == "Enum") return `${nofix(type)}`;
  if (kind == "UInt") return "number";
  if (kind == "ULongLong") return "bigint | number";
  if (kind == "Bool") return "boolean | number | bigint";
  if (kind == "Double") return "number";
  if (kind == "ULong") return "bigint | number";
  if (kind == "Float") return "number";
  if (kind == "UShort") return "number";
  if (kind == "Int") return "number";
  throw new Error(
    `setter type: kind ${kind} in ${name}.${fname} not implemented`,
  );
}

function translateKindToDeno(kind: string) {
  if (kind == "Pointer") return "Deno.PointerValue";
  if (kind == "Void") return "void";
  if (kind == "Enum") return "number";
  if (kind == "UInt") return "number";
  if (kind == "Record") return "Uint8Array";
  if (kind == "ULongLong") return "number | bigint";
  if (kind == "Bool") return "boolean";
  if (kind == "Double") return "number";
  if (kind == "ULong") return "number | bigint";
  if (kind == "Float") return "number";
  if (kind == "UShort") return "number";
  if (kind == "Int") return "number";
  throw new Error(`kind ${kind} not implemented`);
}

function extractErgos(ctx: Ctx) {
  const { classes, functions, tu } = ctx;
  tu.getCursor().visitChildren((cursor) => {
    if (cursor.kind == CXCursorKind.CXCursor_TypedefDecl) {
      const name = cursor.getSpelling();
      const implType = cursor.getTypedefDeclarationOfUnderlyingType()
        ?.getPointeeType();
      if (implType && implType.getSpelling().includes("Impl")) {
        classes[name] = {};
      }
    }
    return CXChildVisitResult.CXChildVisit_Recurse;
  });
  tu.getCursor().visitChildren((cursor) => {
    // handle function decl
    if (cursor.kind == CXCursorKind.CXCursor_FunctionDecl) {
      const name = cursor.getSpelling();
      let group: string | undefined = undefined;
      for (const g of Object.keys(classes)) {
        if (nofix(name).startsWith(nofix(g))) {
          if (group == null || g.length > group.length) {
            group = g;
          }
        }
      }
      const result = {
        kind: cursor.getResultType()!.getCanonicalType().getKindSpelling(),
        type: cursor.getResultType()!.getSpelling(),
      };
      const parameters = [];
      for (let i = 0; i < cursor.getNumberOfArguments(); i++) {
        const pCursor = cursor.getArgument(i)!;
        parameters.push({
          name: pCursor.getSpelling(),
          kind: pCursor.getType()!.getCanonicalType().getKindSpelling(),
          type: pCursor.getType()!.getSpelling(),
        });
      }
      if (group) {
        classes[group][name] = { result, parameters };
      } else {
        functions[name] = { result, parameters };
      }
    }
    return CXChildVisitResult.CXChildVisit_Continue;
  });
}

function generateErgos(ctx: Ctx) {
  const { classes, functions } = ctx;
  const fns = sep("\n")(km(functions, (x) => generateFunction(ctx, x)));
  const cls = sep("\n")(km(classes, (x) => generateClass(ctx, x)));
  return dedent`
    ${fns}
    ${cls}
  `;
}

function generateClass(ctx: Ctx, className: string) {
  const specs = ctx.classes[className];
  const methods = sep("\n")(
    km(specs, (methodName) => generateClassMethod(ctx, className, methodName)),
  );
  return dedent`
    export class ${nofix(className)} extends U.ClassBase { 
      constructor(pointer: Deno.PointerValue, parent?: U.ClassBase) {
        super(pointer, parent);
        U.registry.register(this, [pointer, lib.symbols.wgpu${
    nofix(className)
  }Release]);
      }
      ${methods}
    }
  `;
}

function generateClassMethod(
  ctx: Ctx,
  className: string,
  methodId: string,
): string {
  const spec = ctx.classes[className][methodId];
  const name = camelCase(nofix(methodId).replace(nofix(className), ""));
  // hide release and reference
  if (name == "release" || name == "reference") return ``;
  const hasCallback = spec.parameters.some((x) => x.name == "callback");
  if (!hasCallback) {
    // ordinary function
    const params = sep(",")(spec.parameters.map((p, i) => {
      // `this` is omitted in param
      if (i == 0) return null;
      // the only struct parameter is optional
      const optional =
        spec.parameters.length == 2 && i == 1 && matchStruct(ctx, p.type)
          ? "?"
          : "";
      return `${p.name}${optional}: ${translateTypeSpec(ctx, p, true)}`;
    }));
    const res = translateTypeSpec(ctx, spec.result);
    const body = generateFunctionBody(ctx, className, methodId);
    return dedent`
      ${name}(${params}): ${res} {
        ${body}
      }
    `;
  } else {
    return generateClassMethodWithCallback(ctx, className, methodId);
  }
}

function generateClassMethodWithCallback(
  ctx: Ctx,
  arg2: string,
  arg3?: string,
): string {
  const isMethod = arg3 != null;
  const functionId = isMethod ? arg3 : arg2;
  const spec = isMethod ? ctx.classes[arg2][functionId] : ctx.functions[arg2];
  const name = isMethod
    ? camelCase(nofix(arg3).replace(nofix(arg2), ""))
    : camelCase(nofix(arg2));
  const prefix = isMethod ? "" : `export function`;
  const idxCb = spec.parameters.findIndex((x) => x.name == "callback")!;
  const callbackSpec = ctx.callbacks[spec.parameters[idxCb].type];
  const paramsBefore = sep(",")(spec.parameters.map((p, i) => {
    if (i == 0) return null;
    if (i >= idxCb) return null;
    return `${p.name}: ${translateTypeSpec(ctx, p)}`;
  }));
  const cbDef = translateTypeSpec(ctx, spec.parameters[idxCb]);
  const argBefore = sep(",")(
    spec.parameters.map((p, i) =>
      isMethod && i == 0
        ? `this.pointer`
        : i >= idxCb
        ? null
        : translateArgument(ctx, p)
    ),
  );
  // skip userdata
  const callbackParams = callbackSpec.parameters.slice(
    0,
    callbackSpec.parameters.length - 1,
  );
  const datasetters = `[` + sep(",")(callbackParams.map((cs, i) => {
    return generateResultTransform(ctx, cs, isMethod, `args[${i}]`);
  })) + `]`;
  const promisetypes = `[${
    sep(",")(callbackParams.map((cs) => translateTypeSpec(ctx, cs)))
  }]`;
  const acomma = idxCb != 0 ? "," : "";
  const pcomma = isMethod ? (idxCb != 1 ? "," : "") : acomma;
  const needPoll = name.includes("Async");
  const promiseImpl = needPoll
    ? `
        let data: ${promisetypes};
        const device = this.findInFamily(Device);
        if (!device) throw new Error("WGPU Object must be associated to Device to call async method.")
        const cb = new Deno.UnsafeCallback(${cbDef}, (...args: U.CbParam<typeof ${cbDef}>) => {
          data = ${datasetters}
        })
        lib.symbols.${functionId}(${argBefore}${acomma} cb.pointer, null);
        const id = setInterval(() => {
          if (lib.symbols.wgpuDevicePoll(device.pointer, 0, null)) {
            clearInterval(id);
            res(data!);
          }
        }, 10);
      `
    : `
        const cb = new Deno.UnsafeCallback(${cbDef}, (...args: U.CbParam<typeof ${cbDef}>) => {
          res(${datasetters} as ${promisetypes});
        })
        lib.symbols.${functionId}(${argBefore}${acomma} cb.pointer, null);
      `;
  return dedent`\
    ${prefix} ${name}(${paramsBefore}): Promise<${promisetypes}>;
    ${prefix} ${name}(${paramsBefore}${pcomma} callback: (...args: ${promisetypes}) => void): Deno.UnsafeCallback<typeof ${cbDef}>
    ${prefix} ${name}(${paramsBefore}${pcomma} callback: Deno.UnsafeCallback<typeof ${cbDef}>): void
    ${prefix} ${name}(${paramsBefore}${pcomma} callback: Deno.PointerValue): void
    ${prefix} ${name}(${paramsBefore}${pcomma} callback?: ((...args: ${promisetypes}) => void) | Deno.UnsafeCallback<typeof ${cbDef}> | Deno.PointerValue): void | Promise<${promisetypes}> | Deno.UnsafeCallback<typeof ${cbDef}> {
      if (callback == null) {
        return new Promise((res) => {
          ${promiseImpl}
        });
      } else if (callback instanceof Deno.UnsafeCallback) {
        lib.symbols.${functionId}(${argBefore}${acomma} callback.pointer, null);
      } else if (callback instanceof Function) {
        const cb = new Deno.UnsafeCallback(${cbDef}, (...args: U.CbParam<typeof ${cbDef}>) => {
          callback(...${datasetters})
        });
        lib.symbols.${functionId}(${argBefore}${acomma} cb.pointer, null);
        return cb;
      } else {
        lib.symbols.${functionId}(${argBefore}${acomma} callback, null);
      }
    }
  `;
}

function generateFunction(ctx: Ctx, functionId: string): string {
  const spec = ctx.functions[functionId];
  const name = camelCase(nofix(functionId));
  const hasCallback = spec.parameters.some((x) => x.name == "callback");
  if (!hasCallback) {
    const params = sep(",")(spec.parameters.map((p, i) => {
      // the only struct parameter is optional
      const optional =
        spec.parameters.length == 1 && i == 0 && matchStruct(ctx, p.type)
          ? "?"
          : "";
      return `${p.name}${optional}: ${translateTypeSpec(ctx, p, true)}`;
    }));
    const res = translateTypeSpec(ctx, spec.result);
    const body = generateFunctionBody(ctx, functionId);
    return dedent`\
    export function ${name}(${params}): ${res} {
      ${body}
    }
  `;
  } else {
    return generateClassMethodWithCallback(ctx, functionId);
  }
}

function matchStruct(ctx: Ctx, type: string): string | null {
  const match = type.match(/^const (\w+) \*$/);
  if (!match) return null;
  if (match[1] in ctx.structs) return match[1];
  return null;
}

function generateFunctionBody(ctx: Ctx, clsOrFn: string, optMId?: string) {
  let spec;
  let method: boolean;
  let id;
  if (optMId == null) {
    spec = ctx.functions[clsOrFn];
    method = false;
    id = clsOrFn;
  } else {
    spec = ctx.classes[clsOrFn][optMId];
    method = true;
    id = optMId;
  }
  const args = sep(",")(
    spec.parameters.map((p, i) =>
      method && i == 0 ? `this.pointer` : translateArgument(ctx, p)
    ),
  );
  const transform = generateResultTransform(ctx, spec.result, method);
  return dedent`
    const result = lib.symbols.${id}(${args});
    return ${transform}
  `;
}

function translateTypeSpec(ctx: Ctx, spec: TypeSpec, allowptr = false): string {
  const { kind, type } = spec;
  const orptr = allowptr ? "| Deno.PointerValue" : "";
  if (kind == "Enum") return nofix(type);
  if (kind == "Pointer") {
    if (type in ctx.callbacks) return nofix(type);
    if (type in ctx.classes) return nofix(type);
    // struct
    const match = type.match(/^const (\w+) \*$/);
    if (match && match[1] in ctx.structs) {
      return `${nofix(match[1])} | To${nofix(match[1])}` + orptr;
    }
  }
  return translateKindToDeno(kind);
}

function generateResultTransform(
  ctx: Ctx,
  spec: TypeSpec,
  method: boolean,
  inner = "result",
): string {
  const { kind, type } = spec;
  if (kind == "Bool") return `${inner} == 1`;
  if (kind == "Enum") return `${inner} as ${nofix(type!)}`;
  if (kind == "Pointer") {
    // class
    if (type && type in ctx.classes) {
      return `new ${nofix(type)}(${inner} ${method ? ", this" : ""})`;
    }
    // struct
    const match = type.match(/^const (\w+) \*$/);
    if (match && match[1] in ctx.structs) {
      return `new ${nofix(match[1])}(${inner})`;
    }
  }
  return inner;
}

function translateArgument(ctx: Ctx, spec: NamedTypeSpec): string {
  if (spec.name == "userdata") return "null";
  if (spec.kind == "Bool") return `${spec.name} ? 1 : 0`;
  if (spec.kind == "Pointer") {
    // class
    if (spec.type in ctx.classes) {
      return `${spec.name}.pointer`;
    }
    // struct
    const match = spec.type.match(/^const (\w+) \*$/);
    if (match && match[1] in ctx.structs) {
      return `${spec.name} instanceof ${
        nofix(match[1])
      } ? ${spec.name}.pointer : U.duckIsPointer(${spec.name}) ? ${spec.name} : ${
        nofix(match[1])
      }.from(${spec.name}).pointer`;
    }
  }
  return spec.name;
}

function generateCallbacks({ callbacks }: Ctx) {
  return sep("\n")(km(callbacks, (name) => {
    const result = `"${
      translateKindToDenoNative(callbacks[name].result.kind)
    }"`;
    const parameters = sep(",")(
      callbacks[name].parameters.map((p) =>
        `"${translateKindToDenoNative(p.kind)}"`
      ),
    );
    return dedent`
      export const ${nofix(name)} = {
        result: ${result},
        parameters: [${parameters}],
      } as const;
    `;
  }));
}
